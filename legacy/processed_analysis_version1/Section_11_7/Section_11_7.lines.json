[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":67},{"state":[],"start":96},{"state":[],"start":97},{"state":[],"start":101},{"state":[],"start":163},{"state":[],"start":164},{"state":[],"start":260},{"state":[],"start":348},{"state":[],"start":443},{"state":[],"start":536},{"state":[],"start":546},{"state":[],"start":547},{"state":[],"start":595},{"state":[],"start":684},{"state":[],"start":685},{"state":[],"start":688},{"state":[],"start":689},{"state":[],"start":709},{"state":[],"start":739},{"state":[],"start":740},{"state":[],"start":766},{"state":[{"type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ) ∧ ¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",132],"isProp":true,"context":[]}],"start":861},{"state":[{"type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ) ∧ ¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",132],"isProp":true,"context":[]}],"start":929},{"state":[{"type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","tag":[],"mvarId":["_uniq",256],"isProp":true,"context":[]}],"start":972},{"state":[{"type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ) ∧ ¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",258],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]}]}],"start":1046},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",3823],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]}]}],"start":1072},{"state":[{"type":"∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","tag":[],"mvarId":["_uniq",4105],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"}]}],"start":1191},{"state":[{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","tag":["pos","_@","_hyg",228],"mvarId":["_uniq",4178],"isProp":false,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",4177],"binderInfo":"default"}]},{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","tag":["neg","_@","_hyg",228],"mvarId":["_uniq",4185],"isProp":false,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",4184],"binderInfo":"default"}]}],"start":1232},{"state":[{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","tag":["neg","_@","_hyg",228],"mvarId":["_uniq",4185],"isProp":false,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",4184],"binderInfo":"default"}]}],"start":1249},{"state":[{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","tag":["neg","_@","_hyg",228],"mvarId":["_uniq",8358],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",4184],"binderInfo":"default"},{"value":"hJ0","type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8357]}]}],"start":1270},{"state":[{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","tag":["neg","_@","_hyg",228],"mvarId":["_uniq",8378],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1312},{"state":[{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) = 1","tag":["h","e'_2","h","e'_5"],"mvarId":["_uniq",9335],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1336},{"state":[{"type":"sSup (f_9_3_21 '' (↑J : Set ℝ)) ≤ 1","tag":["h","e'_2","h","e'_5","a"],"mvarId":["_uniq",10224],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]},{"type":"1 ≤ sSup (f_9_3_21 '' (↑J : Set ℝ))","tag":["h","e'_2","h","e'_5","a"],"mvarId":["_uniq",10225],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1358},{"state":[{"type":"(f_9_3_21 '' (↑J : Set ℝ)).Nonempty","tag":["h","e'_2","h","e'_5","a","h₁"],"mvarId":["_uniq",10252],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]},{"type":"∀ b ∈ f_9_3_21 '' (↑J : Set ℝ), b ≤ 1","tag":["h","e'_2","h","e'_5","a","h₂"],"mvarId":["_uniq",10253],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1379},{"state":[{"type":"∀ b ∈ f_9_3_21 '' (↑J : Set ℝ), b ≤ 1","tag":["h","e'_2","h","e'_5","a","h₂"],"mvarId":["_uniq",10253],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1413},{"state":[{"type":"1 ≤ sSup (f_9_3_21 '' (↑J : Set ℝ))","tag":["h","e'_2","h","e'_5","a"],"mvarId":["_uniq",10225],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1425},{"state":[{"type":"BddAbove (f_9_3_21 '' (↑J : Set ℝ))","tag":[],"mvarId":["_uniq",24811],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]},{"type":"1 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",24812],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1487},{"state":[{"type":"1 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",24812],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",8375],"binderInfo":"default"}]}],"start":1525},{"state":[{"type":"1 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",36806],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",8372],"binderInfo":"default"},{"type":"J.a < J.b","name":["hJ0'"],"isProp":true,"id":["_uniq",36299],"binderInfo":"default"},{"type":"ℝ","name":["z"],"isProp":false,"id":["_uniq",36793],"binderInfo":"default"},{"type":"z ∈ Set.range Rat.cast","name":["hz"],"isProp":true,"id":["_uniq",36801],"binderInfo":"default"},{"type":"z ∈ Set.Ioo J.a J.b","name":["hz'"],"isProp":true,"id":["_uniq",36805],"binderInfo":"default"}]}],"start":1627},{"state":[{"type":"∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x","tag":["intro"],"mvarId":["_uniq",45216],"isProp":true,"context":[{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",3860],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",4111],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",4114],"binderInfo":"default"},{"type":"J.a < J.b","name":["hJ0'"],"isProp":true,"id":["_uniq",36299],"binderInfo":"default"},{"type":"BddOn f_9_3_21 (Set.Icc 0 1)","name":["hbdd"],"isProp":true,"id":["_uniq",45167],"binderInfo":"default"},{"type":"(↑J : Set ℝ).Nontrivial","name":["hJ0"],"isProp":true,"id":["_uniq",45168],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",45201],"binderInfo":"default"},{"type":"J.a < (↑q : ℝ) ∧ (↑q : ℝ) < J.b","name":["hz'"],"isProp":true,"id":["_uniq",45215],"binderInfo":"default"}]}],"start":1670},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",4108],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]}]}],"start":1753},{"state":[{"type":"upper_riemann_sum f_9_3_21 P = 1","tag":[],"mvarId":["_uniq",47744],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",47713],"binderInfo":"default"}]}],"start":1833},{"state":[{"type":"∑ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 1","tag":[],"mvarId":["_uniq",55301],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",47713],"binderInfo":"default"}]}],"start":1862},{"state":[{"type":"∑ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 1","tag":[],"mvarId":["_uniq",55301],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",47713],"binderInfo":"default"}]}],"start":1871},{"state":[],"start":1951},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",47747],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"value":"fun P =>\n  id\n    (Trans.trans (Finset.sum_congr rfl (not_integrable._proof_5 hbdd hsup P))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 1)\n            (Eq.trans (Partition.sum_of_length (Icc 0 1) P)\n              (Eq.trans\n                (sup_of_le_left (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_zero (Icc 0 1).b)) zero_le_one._simp_1)))\n                (sub_zero (Icc 0 1).b))))\n          (eq_self (Icc 0 1).b))))","type":"∀ (P : Partition (Icc 0 1)), upper_riemann_sum f_9_3_21 P = 1","name":["hupper"],"isProp":true,"id":["_uniq",47746]}]}],"start":2004},{"state":[{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","tag":[],"mvarId":["_uniq",68425],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"value":"fun P =>\n  id\n    (Trans.trans (Finset.sum_congr rfl (not_integrable._proof_5 hbdd hsup P))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 1)\n            (Eq.trans (Partition.sum_of_length (Icc 0 1) P)\n              (Eq.trans\n                (sup_of_le_left (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_zero (Icc 0 1).b)) zero_le_one._simp_1)))\n                (sub_zero (Icc 0 1).b))))\n          (eq_self (Icc 0 1).b))))","type":"∀ (P : Partition (Icc 0 1)), upper_riemann_sum f_9_3_21 P = 1","name":["hupper"],"isProp":true,"id":["_uniq",47746]}]}],"start":2067},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",70667],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]}]}],"start":2120},{"state":[{"type":"∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":[],"mvarId":["_uniq",70972],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"}]}],"start":2234},{"state":[{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":["pos","_@","_hyg",781],"mvarId":["_uniq",71045],"isProp":false,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",71044],"binderInfo":"default"}]},{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":["neg","_@","_hyg",781],"mvarId":["_uniq",71052],"isProp":false,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",71051],"binderInfo":"default"}]}],"start":2275},{"state":[{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":["neg","_@","_hyg",781],"mvarId":["_uniq",71052],"isProp":false,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",71051],"binderInfo":"default"}]}],"start":2292},{"state":[{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":["neg","_@","_hyg",781],"mvarId":["_uniq",75278],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0"],"isProp":true,"id":["_uniq",71051],"binderInfo":"default"},{"value":"hJ0","type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75277]}]}],"start":2313},{"state":[{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":["neg","_@","_hyg",781],"mvarId":["_uniq",75298],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2355},{"state":[{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) = 0","tag":["h","e'_2","h","e'_5"],"mvarId":["_uniq",76162],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2380},{"state":[{"type":"sInf (f_9_3_21 '' (↑J : Set ℝ)) ≤ 0","tag":["h","e'_2","h","e'_5","a"],"mvarId":["_uniq",77118],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]},{"type":"0 ≤ sInf (f_9_3_21 '' (↑J : Set ℝ))","tag":["h","e'_2","h","e'_5","a"],"mvarId":["_uniq",77119],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2402},{"state":[{"type":"BddBelow (f_9_3_21 '' (↑J : Set ℝ))","tag":[],"mvarId":["_uniq",77139],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]},{"type":"0 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",77140],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2466},{"state":[{"type":"0 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",77140],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2506},{"state":[{"type":"0 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",92677],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"J.a < J.b","name":["hJ0'"],"isProp":true,"id":["_uniq",92674],"binderInfo":"default"}]}],"start":2525},{"state":[{"type":"0 ∈ f_9_3_21 '' (↑J : Set ℝ)","tag":[],"mvarId":["_uniq",93071],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"J.a < J.b","name":["hJ0'"],"isProp":true,"id":["_uniq",92674],"binderInfo":"default"},{"type":"ℝ","name":["z"],"isProp":false,"id":["_uniq",93058],"binderInfo":"default"},{"type":"z ∈ {x | Irrational x}","name":["hz"],"isProp":true,"id":["_uniq",93066],"binderInfo":"default"},{"type":"z ∈ Set.Ioo J.a J.b","name":["hz'"],"isProp":true,"id":["_uniq",93070],"binderInfo":"default"}]}],"start":2596},{"state":[{"type":"∃ x ∈ (↑J : Set ℝ), ∀ (x_1 : ℚ), ¬(↑x_1 : ℝ) = x","tag":[],"mvarId":["_uniq",109744],"isProp":true,"context":[{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 _fvar.257 P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 _fvar.257 P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"J.a < J.b","name":["hJ0'"],"isProp":true,"id":["_uniq",92674],"binderInfo":"default"},{"type":"ℝ","name":["z"],"isProp":false,"id":["_uniq",93058],"binderInfo":"default"},{"type":"Irrational z","name":["hz"],"isProp":true,"id":["_uniq",93066],"binderInfo":"default"},{"type":"BddOn f_9_3_21 (Set.Icc 0 1)","name":["hbdd"],"isProp":true,"id":["_uniq",109737],"binderInfo":"default"},{"type":"(↑J : Set ℝ).Nontrivial","name":["hJ0"],"isProp":true,"id":["_uniq",109738],"binderInfo":"default"},{"type":"J.a < z ∧ z < J.b","name":["hz'"],"isProp":true,"id":["_uniq",109739],"binderInfo":"default"}]}],"start":2612},{"state":[{"type":"∀ (x : ℚ), ¬(↑x : ℝ) = z","tag":[],"mvarId":["_uniq",109830],"isProp":true,"context":[{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 _fvar.257 P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 _fvar.257 P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"J.a < J.b","name":["hJ0'"],"isProp":true,"id":["_uniq",92674],"binderInfo":"default"},{"type":"ℝ","name":["z"],"isProp":false,"id":["_uniq",93058],"binderInfo":"default"},{"type":"Irrational z","name":["hz"],"isProp":true,"id":["_uniq",93066],"binderInfo":"default"},{"type":"BddOn f_9_3_21 (Set.Icc 0 1)","name":["hbdd"],"isProp":true,"id":["_uniq",109737],"binderInfo":"default"},{"type":"(↑J : Set ℝ).Nontrivial","name":["hJ0"],"isProp":true,"id":["_uniq",109738],"binderInfo":"default"},{"type":"J.a < z ∧ z < J.b","name":["hz'"],"isProp":true,"id":["_uniq",109739],"binderInfo":"default"}]}],"start":2691},{"state":[{"type":"0 ≤ sInf (f_9_3_21 '' (↑J : Set ℝ))","tag":["h","e'_2","h","e'_5","a"],"mvarId":["_uniq",77119],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2735},{"state":[{"type":"(f_9_3_21 '' (↑J : Set ℝ)).Nonempty","tag":["h","e'_2","h","e'_5","a","h₁"],"mvarId":["_uniq",112120],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]},{"type":"∀ b ∈ f_9_3_21 '' (↑J : Set ℝ), 0 ≤ b","tag":["h","e'_2","h","e'_5","a","h₂"],"mvarId":["_uniq",112121],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2754},{"state":[{"type":"∀ b ∈ f_9_3_21 '' (↑J : Set ℝ), 0 ≤ b","tag":["h","e'_2","h","e'_5","a","h₂"],"mvarId":["_uniq",112121],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",70704],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",70978],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",70981],"binderInfo":"default"},{"type":"¬Subsingleton (↑(↑J : Set ℝ) : Type)","name":["hJ0"],"isProp":true,"id":["_uniq",75292],"binderInfo":"default"},{"type":"¬J.length = 0","name":["hJ0'"],"isProp":true,"id":["_uniq",75295],"binderInfo":"default"}]}],"start":2786},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",70975],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x = 0)\n          (Eq.trans (congrArg (HMul.hMul (sInf (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n            (mul_zero (sInf (f_9_3_21 '' (↑J : Set ℝ))))))\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (0 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sInf (f_9_3_21 '' (↑J : Set ℝ))) 0\n              (le_antisymm\n                (csInf_le_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n                    (Exists.intro 0\n                      (not_integrable._proof_6 hbdd hsup hupper P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 0)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_right_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                            Set.mem_range._simp_1)\n                                          one_ne_zero._simp_1)\n                                        imp_false._simp_1)\n                                      not_exists._simp_1))))))\n                        (Exists.intro z\n                          ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                              (of_eq_true\n                                (Eq.trans (Eq.trans (congrArg (fun x => z ∈ x) (set_Ioo J.a J.b)) Set.mem_Ioo._simp_1)\n                                  (Eq.trans\n                                    (congr (congrArg And (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).1))\n                                      (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).2))\n                                    (and_self True)))),\n                            fun q =>\n                            Mathlib.Tactic.Contrapose.mtr\n                              (Eq.mpr\n                                (id\n                                  (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq ((↑q : ℝ) = z))\n                                    (Eq.refl ¬Irrational z)))\n                                fun hz =>\n                                of_eq_true\n                                  (Eq.trans\n                                    (congrArg Not\n                                      (Eq.trans (congrArg Irrational (Eq.symm hz)) (Rat.not_irrational._simp_1 q)))\n                                    not_false_eq_true))\n                              x.left⟩))\n                    (Classical.choose\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0'))))\n                  (have this :=\n                    Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero) (Eq.refl true);\n                  this))\n                (le_csInf\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq ⋯) ⋯)) ⋯) ⋯)\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","name":["hinf"],"isProp":true,"id":["_uniq",70974]}]}],"start":2796},{"state":[{"type":"lower_riemann_sum f_9_3_21 P = 0","tag":[],"mvarId":["_uniq",141809],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x = 0)\n          (Eq.trans (congrArg (HMul.hMul (sInf (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n            (mul_zero (sInf (f_9_3_21 '' (↑J : Set ℝ))))))\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (0 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sInf (f_9_3_21 '' (↑J : Set ℝ))) 0\n              (le_antisymm\n                (csInf_le_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n                    (Exists.intro 0\n                      (not_integrable._proof_6 hbdd hsup hupper P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 0)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_right_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                            Set.mem_range._simp_1)\n                                          one_ne_zero._simp_1)\n                                        imp_false._simp_1)\n                                      not_exists._simp_1))))))\n                        (Exists.intro z\n                          ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                              (of_eq_true\n                                (Eq.trans (Eq.trans (congrArg (fun x => z ∈ x) (set_Ioo J.a J.b)) Set.mem_Ioo._simp_1)\n                                  (Eq.trans\n                                    (congr (congrArg And (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).1))\n                                      (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).2))\n                                    (and_self True)))),\n                            fun q =>\n                            Mathlib.Tactic.Contrapose.mtr\n                              (Eq.mpr\n                                (id\n                                  (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq ((↑q : ℝ) = z))\n                                    (Eq.refl ¬Irrational z)))\n                                fun hz =>\n                                of_eq_true\n                                  (Eq.trans\n                                    (congrArg Not\n                                      (Eq.trans (congrArg Irrational (Eq.symm hz)) (Rat.not_irrational._simp_1 q)))\n                                    not_false_eq_true))\n                              x.left⟩))\n                    (Classical.choose\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0'))))\n                  (have this :=\n                    Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero) (Eq.refl true);\n                  this))\n                (le_csInf\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq ⋯) ⋯)) ⋯) ⋯)\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","name":["hinf"],"isProp":true,"id":["_uniq",70974]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",141778],"binderInfo":"default"}]}],"start":2876},{"state":[{"type":"∑ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","tag":[],"mvarId":["_uniq",149540],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x = 0)\n          (Eq.trans (congrArg (HMul.hMul (sInf (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n            (mul_zero (sInf (f_9_3_21 '' (↑J : Set ℝ))))))\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (0 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sInf (f_9_3_21 '' (↑J : Set ℝ))) 0\n              (le_antisymm\n                (csInf_le_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n                    (Exists.intro 0\n                      (not_integrable._proof_6 hbdd hsup hupper P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 0)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_right_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                            Set.mem_range._simp_1)\n                                          one_ne_zero._simp_1)\n                                        imp_false._simp_1)\n                                      not_exists._simp_1))))))\n                        (Exists.intro z\n                          ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                              (of_eq_true\n                                (Eq.trans (Eq.trans (congrArg (fun x => z ∈ x) (set_Ioo J.a J.b)) Set.mem_Ioo._simp_1)\n                                  (Eq.trans\n                                    (congr (congrArg And (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).1))\n                                      (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).2))\n                                    (and_self True)))),\n                            fun q =>\n                            Mathlib.Tactic.Contrapose.mtr\n                              (Eq.mpr\n                                (id\n                                  (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq ((↑q : ℝ) = z))\n                                    (Eq.refl ¬Irrational z)))\n                                fun hz =>\n                                of_eq_true\n                                  (Eq.trans\n                                    (congrArg Not\n                                      (Eq.trans (congrArg Irrational (Eq.symm hz)) (Rat.not_irrational._simp_1 q)))\n                                    not_false_eq_true))\n                              x.left⟩))\n                    (Classical.choose\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0'))))\n                  (have this :=\n                    Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero) (Eq.refl true);\n                  this))\n                (le_csInf\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq ⋯) ⋯)) ⋯) ⋯)\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","name":["hinf"],"isProp":true,"id":["_uniq",70974]},{"type":"Partition (Icc 0 1)","name":["P"],"isProp":false,"id":["_uniq",141778],"binderInfo":"default"}]}],"start":2911},{"state":[],"start":2992},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",141812],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x = 0)\n          (Eq.trans (congrArg (HMul.hMul (sInf (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n            (mul_zero (sInf (f_9_3_21 '' (↑J : Set ℝ))))))\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (0 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sInf (f_9_3_21 '' (↑J : Set ℝ))) 0\n              (le_antisymm\n                (csInf_le_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n                    (Exists.intro 0\n                      (not_integrable._proof_6 hbdd hsup hupper P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 0)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_right_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                            Set.mem_range._simp_1)\n                                          one_ne_zero._simp_1)\n                                        imp_false._simp_1)\n                                      not_exists._simp_1))))))\n                        (Exists.intro z\n                          ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                              (of_eq_true\n                                (Eq.trans (Eq.trans (congrArg (fun x => z ∈ x) (set_Ioo J.a J.b)) Set.mem_Ioo._simp_1)\n                                  (Eq.trans\n                                    (congr (congrArg And (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).1))\n                                      (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).2))\n                                    (and_self True)))),\n                            fun q =>\n                            Mathlib.Tactic.Contrapose.mtr\n                              (Eq.mpr\n                                (id\n                                  (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq ((↑q : ℝ) = z))\n                                    (Eq.refl ¬Irrational z)))\n                                fun hz =>\n                                of_eq_true\n                                  (Eq.trans\n                                    (congrArg Not\n                                      (Eq.trans (congrArg Irrational (Eq.symm hz)) (Rat.not_irrational._simp_1 q)))\n                                    not_false_eq_true))\n                              x.left⟩))\n                    (Classical.choose\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0'))))\n                  (have this :=\n                    Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero) (Eq.refl true);\n                  this))\n                (le_csInf\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq ⋯) ⋯)) ⋯) ⋯)\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","name":["hinf"],"isProp":true,"id":["_uniq",70974]},{"value":"fun P =>\n  id\n    (Trans.trans (Finset.sum_congr rfl (not_integrable._proof_8 hbdd hsup hupper hinf P))\n      (of_eq_true (Eq.trans (congrArg (fun x => x = 0) Finset.sum_const_zero) (eq_self 0))))","type":"∀ (P : Partition (Icc 0 1)), lower_riemann_sum f_9_3_21 P = 0","name":["hlower"],"isProp":true,"id":["_uniq",141811]}]}],"start":3015},{"state":[{"type":"lower_integral f_9_3_21 (Icc 0 1) = 0","tag":[],"mvarId":["_uniq",158263],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x = 0)\n          (Eq.trans (congrArg (HMul.hMul (sInf (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n            (mul_zero (sInf (f_9_3_21 '' (↑J : Set ℝ))))))\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (0 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sInf (f_9_3_21 '' (↑J : Set ℝ))) 0\n              (le_antisymm\n                (csInf_le_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n                    (Exists.intro 0\n                      (not_integrable._proof_6 hbdd hsup hupper P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 0)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_right_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                            Set.mem_range._simp_1)\n                                          one_ne_zero._simp_1)\n                                        imp_false._simp_1)\n                                      not_exists._simp_1))))))\n                        (Exists.intro z\n                          ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                              (of_eq_true\n                                (Eq.trans (Eq.trans (congrArg (fun x => z ∈ x) (set_Ioo J.a J.b)) Set.mem_Ioo._simp_1)\n                                  (Eq.trans\n                                    (congr (congrArg And (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).1))\n                                      (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).2))\n                                    (and_self True)))),\n                            fun q =>\n                            Mathlib.Tactic.Contrapose.mtr\n                              (Eq.mpr\n                                (id\n                                  (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq ((↑q : ℝ) = z))\n                                    (Eq.refl ¬Irrational z)))\n                                fun hz =>\n                                of_eq_true\n                                  (Eq.trans\n                                    (congrArg Not\n                                      (Eq.trans (congrArg Irrational (Eq.symm hz)) (Rat.not_irrational._simp_1 q)))\n                                    not_false_eq_true))\n                              x.left⟩))\n                    (Classical.choose\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0'))))\n                  (have this :=\n                    Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero) (Eq.refl true);\n                  this))\n                (le_csInf\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq ⋯) ⋯)) ⋯) ⋯)\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","name":["hinf"],"isProp":true,"id":["_uniq",70974]},{"value":"fun P =>\n  id\n    (Trans.trans (Finset.sum_congr rfl (not_integrable._proof_8 hbdd hsup hupper hinf P))\n      (of_eq_true (Eq.trans (congrArg (fun x => x = 0) Finset.sum_const_zero) (eq_self 0))))","type":"∀ (P : Partition (Icc 0 1)), lower_riemann_sum f_9_3_21 P = 0","name":["hlower"],"isProp":true,"id":["_uniq",141811]}]}],"start":3078},{"state":[{"type":"¬IntegrableOn f_9_3_21 (Icc 0 1)","tag":[],"mvarId":["_uniq",160461],"isProp":true,"context":[{"value":"Exists.intro 1 fun x a =>\n  if h : ∃ y, (↑y : ℝ) = x then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_true 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1) (eq_true h))))\n            abs_one))\n        (le_refl._simp_1 1))\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ 1)\n          (Eq.trans\n            (congrArg abs\n              (ite_cond_eq_false 1 0\n                (Eq.trans (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ) Set.mem_range._simp_1)\n                  (eq_false h))))\n            abs_zero))\n        zero_le_one._simp_1)","type":"BddOn f_9_3_21 (↑(Icc 0 1) : Set ℝ)","name":["hbdd"],"isProp":true,"id":["_uniq",257]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans (congrArg (HMul.hMul (sSup (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n              (mul_zero (sSup (f_9_3_21 '' (↑J : Set ℝ))))))\n          hJ0)\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (1 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sSup (f_9_3_21 '' (↑J : Set ℝ))) 1\n              (le_antisymm\n                (csSup_le\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr\n                      (id\n                        (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq (f_9_3_21 '' (↑J : Set ℝ)))\n                          (Mathlib.Tactic.PushNeg.not_not_eq (Subsingleton (↑(↑J : Set ℝ) : Type)))))\n                      fun hJ0 =>\n                      of_eq_true\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (fun x => Subsingleton (↑x : Type)) (id (Eq.mp Set.image_eq_empty._simp_1 hJ0)))\n                            (Set.subsingleton_coe._simp_1 ∅))\n                          Set.subsingleton_empty._simp_1))\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0))\n                  (not_integrable._proof_3 hbdd P J hJ\n                    (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0'))\n                (le_csSup_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddAbove_def)))\n                    (Exists.intro 1\n                      (not_integrable._proof_4 hbdd P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 1)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_left_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans\n                                            (congrArg Not\n                                              (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                                Set.mem_range._simp_1))\n                                            not_exists._simp_1)\n                                          zero_ne_one._simp_1)\n                                        imp_false._simp_1)\n                                      (Eq.trans Classical.not_forall._simp_1\n                                        (congrArg Exists (funext fun x_1 => Decidable.not_not._simp_1)))))))))\n                        (Exists.casesOn (Eq.mp Set.mem_range._simp_1 x.left) fun q h =>\n                          Eq.ndrec (motive := fun z => J.a < z ∧ z < J.b → ∃ x ∈ (↑J : Set ℝ), ∃ y, (↑y : ℝ) = x)\n                            (fun hz' =>\n                              Exists.intro (↑q : ℝ)\n                                ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                                    (of_eq_true\n                                      (Eq.trans\n                                        (Eq.trans (congrArg (fun x => (↑q : ℝ) ∈ x) (set_Ioo J.a J.b))\n                                          Set.mem_Ioo._simp_1)\n                                        (Eq.trans (congr (congrArg And (eq_true hz'.1)) (eq_true hz'.2))\n                                          (and_self True)))),\n                                  Exists.intro q rfl⟩)\n                            h (Eq.mp Set.mem_Ioo._simp_1 x.right)))\n                    (Classical.choose\n                      (Dense.exists_between Rat.denseRange_cast\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec ⋯))\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sSup (f_9_3_21 '' (↑J : Set ℝ)) * J.length = J.length","name":["hsup"],"isProp":true,"id":["_uniq",4107]},{"type":"upper_integral f_9_3_21 (Icc 0 1) = 1","name":["hupper"],"isProp":true,"id":["_uniq",68426]},{"value":"fun P J hJ =>\n  if hJ0 : J.length = 0 then\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x = 0)\n          (Eq.trans (congrArg (HMul.hMul (sInf (f_9_3_21 '' (↑J : Set ℝ)))) hJ0)\n            (mul_zero (sInf (f_9_3_21 '' (↑J : Set ℝ))))))\n        (eq_self 0))\n  else\n    have hJ0' := hJ0;\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length) (0 * J.length)\n          (eq_of_heq\n            ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a * a_1 ≍ a' * a'_1) e'_5\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a * a_1 ≍ a' * a'_1)\n                      (fun e_5 h =>\n                        Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a * a_1 ≍ a * a'_1) e'_6\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a * a_1 ≍ a * a')\n                              (fun e_6 h => HEq.refl (a * a_1)) (Eq.symm h) e'_6)\n                          (Eq.refl a'_1) (HEq.refl e'_6))\n                      (Eq.symm h) e'_5)\n                  (Eq.refl a') (HEq.refl e'_5))\n              ℝ ℝ ℝ instHMul (sInf (f_9_3_21 '' (↑J : Set ℝ))) 0\n              (le_antisymm\n                (csInf_le_of_le\n                  (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n                    (Exists.intro 0\n                      (not_integrable._proof_6 hbdd hsup hupper P J hJ\n                        (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hJ0) hJ0')))\n                  ((fun z x =>\n                      Eq.mpr\n                        (id\n                          (Eq.trans (Set.mem_image._simp_1 f_9_3_21 (↑J : Set ℝ) 0)\n                            (congrArg Exists\n                              (funext fun x =>\n                                congrArg (And (x ∈ (↑J : Set ℝ)))\n                                  (Eq.trans ite_eq_right_iff._simp_1\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (implies_congr\n                                          (Eq.trans (congrArg (fun x_1 => x ∈ x_1) Set.image_univ)\n                                            Set.mem_range._simp_1)\n                                          one_ne_zero._simp_1)\n                                        imp_false._simp_1)\n                                      not_exists._simp_1))))))\n                        (Exists.intro z\n                          ⟨(subset_iff (Ioo J.a J.b) J).mp (Ioo_subset J)\n                              (of_eq_true\n                                (Eq.trans (Eq.trans (congrArg (fun x => z ∈ x) (set_Ioo J.a J.b)) Set.mem_Ioo._simp_1)\n                                  (Eq.trans\n                                    (congr (congrArg And (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).1))\n                                      (eq_true (Eq.mp Set.mem_Ioo._simp_1 x.right).2))\n                                    (and_self True)))),\n                            fun q =>\n                            Mathlib.Tactic.Contrapose.mtr\n                              (Eq.mpr\n                                (id\n                                  (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq ((↑q : ℝ) = z))\n                                    (Eq.refl ¬Irrational z)))\n                                fun hz =>\n                                of_eq_true\n                                  (Eq.trans\n                                    (congrArg Not\n                                      (Eq.trans (congrArg Irrational (Eq.symm hz)) (Rat.not_irrational._simp_1 q)))\n                                    not_false_eq_true))\n                              x.left⟩))\n                    (Classical.choose\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0')))\n                    (Classical.choose_spec\n                      (Dense.exists_between dense_irrational\n                        (Eq.mp\n                          (Eq.trans\n                            (congrArg Not\n                              (Eq.trans sup_eq_right._simp_1\n                                (Eq.trans tsub_le_iff_right._simp_1 (congrArg (LE.le J.b) (zero_add J.a)))))\n                            not_le._simp_1)\n                          hJ0'))))\n                  (have this :=\n                    Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero) (Eq.refl true);\n                  this))\n                (le_csInf\n                  (Mathlib.Tactic.Contrapose.mtr\n                    (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq ⋯) ⋯)) ⋯) ⋯)\n                  ⋯))\n              ⋯ ⋯ ⋯))\n          ⋯ ⋯ ⋯))\n      ⋯","type":"∀ (P : Partition (Icc 0 1)), ∀ J ∈ P.intervals, sInf (f_9_3_21 '' (↑J : Set ℝ)) * J.length = 0","name":["hinf"],"isProp":true,"id":["_uniq",70974]},{"type":"lower_integral f_9_3_21 (Icc 0 1) = 0","name":["hlower"],"isProp":true,"id":["_uniq",158264]}]}],"start":3131},{"state":[],"start":3139},{"state":[],"start":3140},{"state":[],"start":3141},{"state":[],"start":3155},{"state":[],"start":3155}]
