[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":79},{"state":[],"start":80},{"state":[],"start":84},{"state":[],"start":158},{"state":[],"start":159},{"state":[],"start":255},{"state":[],"start":343},{"state":[],"start":438},{"state":[],"start":531},{"state":[],"start":541},{"state":[],"start":542},{"state":[],"start":590},{"state":[],"start":649},{"state":[],"start":706},{"state":[],"start":707},{"state":[],"start":710},{"state":[],"start":711},{"state":[],"start":731},{"state":[],"start":752},{"state":[],"start":766},{"state":[],"start":767},{"state":[],"start":789},{"state":[],"start":887},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",239],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"}]}],"start":912},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",239],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"}]}],"start":985},{"state":[{"type":"BddOn f (↑I : Set ℝ)","tag":[],"mvarId":["_uniq",328],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"}]}],"start":1018},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",330],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]}]}],"start":1113},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":[],"mvarId":["_uniq",433],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]}]}],"start":1142},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["pos","_@","_hyg",87],"mvarId":["_uniq",495],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"type":"I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",494],"binderInfo":"default"}]},{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",502],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"type":"¬I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",501],"binderInfo":"default"}]}],"start":1172},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",502],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"type":"¬I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",501],"binderInfo":"default"}]}],"start":1216},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",5552],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"type":"I.a < I.b","name":["hsing"],"isProp":true,"id":["_uniq",5549],"binderInfo":"default"}]}],"start":1241},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",5599],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"type":"a < I.b","name":["hsing"],"isProp":true,"id":["_uniq",5596],"binderInfo":"default"}]}],"start":1256},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",5682],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"}]}],"start":1271},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",5829],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]}]}],"start":1310},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",6515],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6380],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6409],"binderInfo":"default"}]}],"start":1403},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",6561],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"}]}],"start":1442},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",13315],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"}]}],"start":1518},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",13478],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"}]}],"start":1565},{"state":[{"type":"0 < N","tag":[],"mvarId":["_uniq",13528],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"}]}],"start":1594},{"state":[{"type":"0 < N","tag":[],"mvarId":["_uniq",13642],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"div_pos hsing' hδ","type":"0 < (b - a) / δ","name":["this"],"isProp":true,"id":["_uniq",13641]}]}],"start":1637},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",13530],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]}]}],"start":1655},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",21160],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]}]}],"start":1725},{"state":[{"type":"∃ P, P.intervals.card = N ∧ ∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","tag":[],"mvarId":["_uniq",26448],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]}]}],"start":1829},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",26450],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"value":"sorry","type":"∃ P, P.intervals.card = N ∧ ∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["this"],"isProp":true,"id":["_uniq",26449]}]}],"start":1841},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",26472],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"}]}],"start":1879},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ ε * (b - a)","tag":[],"mvarId":["_uniq",26472],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"}]}],"start":1888},{"state":[{"type":"upper_integral f I - lower_integral f I ≤\n  ∑ J ∈ P.intervals, (sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ))) * J.length","tag":[],"mvarId":["_uniq",26694],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"}]}],"start":1970},{"state":[{"type":"upper_integral f I - lower_integral f I ≤\n  ∑ J ∈ P.intervals, (sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ))) * J.length","tag":[],"mvarId":["_uniq",27068],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"value":"upper_integ_le_upper_sum hfbound P","type":"upper_integral f I ≤ upper_riemann_sum f P","name":["h1"],"isProp":true,"id":["_uniq",27067]}]}],"start":2024},{"state":[{"type":"upper_integral f I - lower_integral f I ≤\n  ∑ J ∈ P.intervals, (sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ))) * J.length","tag":[],"mvarId":["_uniq",27076],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"value":"upper_integ_le_upper_sum hfbound P","type":"upper_integral f I ≤ upper_riemann_sum f P","name":["h1"],"isProp":true,"id":["_uniq",27067]},{"value":"lower_integ_ge_lower_sum hfbound P","type":"lower_riemann_sum f P ≤ lower_integral f I","name":["h2"],"isProp":true,"id":["_uniq",27075]}]}],"start":2078},{"state":[{"type":"upper_integral f I ≤\n  ∑ x ∈ P.intervals, sSup (f '' (↑x : Set ℝ)) * x.length - ∑ x ∈ P.intervals, sInf (f '' (↑x : Set ℝ)) * x.length +\n    lower_integral f I","tag":[],"mvarId":["_uniq",91303],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf✝"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos _fvar.6556 _fvar.6585;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) _fvar.6585)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"value":"upper_integ_le_upper_sum hfbound P","type":"upper_integral f I ≤ ∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length","name":["h1"],"isProp":true,"id":["_uniq",27067]},{"value":"lower_integ_ge_lower_sum hfbound P","type":"∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length ≤ lower_integral f I","name":["h2"],"isProp":true,"id":["_uniq",27075]},{"type":"∀ (ε : ℝ), 0 < ε → ∃ δ, 0 < δ ∧ ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), dist x x₀ ≤ δ → dist (f x) (f x₀) ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",91294],"binderInfo":"default"},{"type":"a < b","name":["hsing'"],"isProp":true,"id":["_uniq",91295],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",91296],"binderInfo":"default"},{"type":"0 < δ","name":["hδ"],"isProp":true,"id":["_uniq",91297],"binderInfo":"default"}]}],"start":2144},{"state":[],"start":2161},{"state":[{"type":"∑ J ∈ P.intervals, (sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ))) * J.length ≤ ∑ J ∈ P.intervals, ε * J.length","tag":[],"mvarId":["_uniq",26743],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"}]}],"start":2214},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ)) ≤ ε","tag":["h","h"],"mvarId":["_uniq",97504],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"}]}],"start":2266},{"state":[{"type":"f x ≤ f y + ε","tag":[],"mvarId":["_uniq",108667],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",108468],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",108470],"binderInfo":"implicit"},{"type":"x ∈ J","name":["hx"],"isProp":true,"id":["_uniq",108546],"binderInfo":"default"},{"type":"y ∈ J","name":["hy"],"isProp":true,"id":["_uniq",108612],"binderInfo":"default"}]}],"start":2342},{"state":[{"type":"f x ≤ f y + ε","tag":[],"mvarId":["_uniq",108730],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",108468],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",108470],"binderInfo":"implicit"},{"type":"x ∈ J","name":["hx"],"isProp":true,"id":["_uniq",108546],"binderInfo":"default"},{"type":"y ∈ J","name":["hy"],"isProp":true,"id":["_uniq",108612],"binderInfo":"default"},{"value":"P.contains J hJ","type":"J ⊆ I","name":["this"],"isProp":true,"id":["_uniq",108729]}]}],"start":2386},{"state":[{"type":"|f x - f y| ≤ ε","tag":[],"mvarId":["_uniq",108798],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",108468],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",108470],"binderInfo":"implicit"},{"type":"x ∈ J","name":["hx"],"isProp":true,"id":["_uniq",108546],"binderInfo":"default"},{"type":"y ∈ J","name":["hy"],"isProp":true,"id":["_uniq",108612],"binderInfo":"default"},{"value":"P.contains J hJ","type":"J ⊆ I","name":["this"],"isProp":true,"id":["_uniq",108729]}]}],"start":2428},{"state":[{"type":"|x - y| ≤ δ","tag":[],"mvarId":["_uniq",108805],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",108468],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",108470],"binderInfo":"implicit"},{"type":"x ∈ J","name":["hx"],"isProp":true,"id":["_uniq",108546],"binderInfo":"default"},{"type":"y ∈ J","name":["hy"],"isProp":true,"id":["_uniq",108612],"binderInfo":"default"},{"value":"P.contains J hJ","type":"J ⊆ I","name":["this"],"isProp":true,"id":["_uniq",108729]}]}],"start":2481},{"state":[{"type":"f x ≤ f y + ε","tag":[],"mvarId":["_uniq",108800],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",108468],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",108470],"binderInfo":"implicit"},{"type":"x ∈ J","name":["hx"],"isProp":true,"id":["_uniq",108546],"binderInfo":"default"},{"type":"y ∈ J","name":["hy"],"isProp":true,"id":["_uniq",108612],"binderInfo":"default"},{"value":"P.contains J hJ","type":"J ⊆ I","name":["this✝"],"isProp":true,"id":["_uniq",108729]},{"value":"hf y (this✝ y hy) x (this✝ x hx)\n  (LE.le.trans (dist_le_length hx hy)\n    (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this✝))","type":"|f x - f y| ≤ ε","name":["this"],"isProp":true,"id":["_uniq",108799]}]}],"start":2551},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ)) ≤ ε","tag":["h","h"],"mvarId":["_uniq",108674],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]}]}],"start":2577},{"state":[{"type":"(f '' (↑J : Set ℝ)).Nonempty","tag":[],"mvarId":["_uniq",126486],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]}]}],"start":2622},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",127016],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]},{"type":"(↑J : Set ℝ) = ∅","name":["h"],"isProp":true,"id":["_uniq",127015],"binderInfo":"default"}]}],"start":2651},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",127288],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]},{"value":"of_eq_true\n  (Eq.trans (Eq.trans (congrArg (fun x => Subsingleton (↑x : Type)) _fvar.127015) (Set.subsingleton_coe._simp_1 ∅))\n    Set.subsingleton_empty._simp_1)","type":"Subsingleton (↑(↑J : Set ℝ) : Type)","name":["h"],"isProp":true,"id":["_uniq",127236]}]}],"start":2713},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",127424],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]},{"type":"(b - a) / (↑N : ℝ) = 0","name":["h"],"isProp":true,"id":["_uniq",127421],"binderInfo":"default"}]}],"start":2777},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ)) ≤ ε","tag":["h","h"],"mvarId":["_uniq",126488],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]},{"value":"Eq.mpr (id Set.image_nonempty._simp_1)\n  (Classical.byContradiction fun h =>\n    have h :=\n      of_eq_true\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => Subsingleton (↑x : Type))\n              (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑J : Set ℝ)) h))\n            (Set.subsingleton_coe._simp_1 ∅))\n          Set.subsingleton_empty._simp_1);\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑N : ℝ)⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left b (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                            (Mathlib.Tactic.Ring.mul_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                              (Mathlib.Tactic.Ring.mul_zero (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right a (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯))\n                  ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"(f '' (↑J : Set ℝ)).Nonempty","name":["hJnon"],"isProp":true,"id":["_uniq",126487]}]}],"start":2831},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) ≤ f y + ε","tag":[],"mvarId":["_uniq",135804],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"fun {x y} hx hy =>\n  have this := P.contains J hJ;\n  have this_1 :=\n    hf y (this y hy) x (this x hx)\n      (LE.le.trans (dist_le_length hx hy)\n        (integ_of_uniform_cts._proof_3 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy\n          this));\n  integ_of_uniform_cts._proof_4 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hx hy this this_1","type":"∀ {x y : ℝ}, x ∈ J → y ∈ J → f x ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",108669]},{"value":"Eq.mpr (id Set.image_nonempty._simp_1)\n  (Classical.byContradiction fun h =>\n    have h :=\n      of_eq_true\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => Subsingleton (↑x : Type))\n              (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑J : Set ℝ)) h))\n            (Set.subsingleton_coe._simp_1 ∅))\n          Set.subsingleton_empty._simp_1);\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑N : ℝ)⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left b (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                            (Mathlib.Tactic.Ring.mul_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                              (Mathlib.Tactic.Ring.mul_zero (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right a (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯))\n                  ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"(f '' (↑J : Set ℝ)).Nonempty","name":["hJnon"],"isProp":true,"id":["_uniq",126487]},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",135567],"binderInfo":"default"},{"type":"y ∈ J","name":["hy"],"isProp":true,"id":["_uniq",135643],"binderInfo":"default"}]}],"start":2903},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ)) ≤ ε","tag":["h","h"],"mvarId":["_uniq",146974],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"Eq.mpr (id Set.image_nonempty._simp_1)\n  (Classical.byContradiction fun h =>\n    have h :=\n      of_eq_true\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => Subsingleton (↑x : Type))\n              (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑J : Set ℝ)) h))\n            (Set.subsingleton_coe._simp_1 ∅))\n          Set.subsingleton_empty._simp_1);\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑N : ℝ)⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left b (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                            (Mathlib.Tactic.Ring.mul_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                              (Mathlib.Tactic.Ring.mul_zero (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right a (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯))\n                  ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"(f '' (↑J : Set ℝ)).Nonempty","name":["hJnon"],"isProp":true,"id":["_uniq",126487]},{"value":"fun y hy =>\n  csSup_le hJnon\n    (integ_of_uniform_cts._proof_5 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ _fvar.108669\n      hJnon y hy)","type":"∀ y ∈ J, sSup (f '' (↑J : Set ℝ)) ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",135806]}]}],"start":2951},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) - ε ≤ sInf (f '' (↑J : Set ℝ))","tag":[],"mvarId":["_uniq",147146],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"Eq.mpr (id Set.image_nonempty._simp_1)\n  (Classical.byContradiction fun h =>\n    have h :=\n      of_eq_true\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => Subsingleton (↑x : Type))\n              (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑J : Set ℝ)) h))\n            (Set.subsingleton_coe._simp_1 ∅))\n          Set.subsingleton_empty._simp_1);\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑N : ℝ)⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left b (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                            (Mathlib.Tactic.Ring.mul_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                              (Mathlib.Tactic.Ring.mul_zero (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right a (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯))\n                  ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"(f '' (↑J : Set ℝ)).Nonempty","name":["hJnon"],"isProp":true,"id":["_uniq",126487]},{"value":"fun y hy =>\n  csSup_le hJnon\n    (integ_of_uniform_cts._proof_5 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ _fvar.108669\n      hJnon y hy)","type":"∀ y ∈ J, sSup (f '' (↑J : Set ℝ)) ≤ f y + ε","name":["this"],"isProp":true,"id":["_uniq",135806]}]}],"start":3012},{"state":[{"type":"sSup (f '' (↑J : Set ℝ)) - sInf (f '' (↑J : Set ℝ)) ≤ ε","tag":["h","h"],"mvarId":["_uniq",155599],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"∀ ε > 0, ∃ δ > 0, ∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), δ.Close x x₀ → ε.Close (f x) (f x₀)","name":["hf✝"],"isProp":true,"id":["_uniq",6549],"binderInfo":"default"},{"type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",6552],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",6553]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",6554]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",6555],"binderInfo":"default"},{"type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",6556],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",6557],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",6558],"binderInfo":"default"},{"type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",6577],"binderInfo":"default"},{"type":"δ > 0","name":["hδ"],"isProp":true,"id":["_uniq",6585],"binderInfo":"default"},{"type":"∀ x₀ ∈ (↑I : Set ℝ), ∀ x ∈ (↑I : Set ℝ), |x - x₀| ≤ δ → |f x - f x₀| ≤ ε","name":["hf"],"isProp":true,"id":["_uniq",6589],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",13474],"binderInfo":"default"},{"type":"(b - a) / δ < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",13477],"binderInfo":"default"},{"value":"have this := div_pos hsing' hδ;\nEq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (Decidable.byContradiction fun a_1 =>\n    ne_of_lt hN\n      (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n        (le_trans (le_of_not_gt a_1) (le_trans (le_of_lt this) (le_refl ((b - a) / δ))))))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",13529]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) hδ)))) hN","type":"(b - a) / (↑N : ℝ) < δ","name":["hN'"],"isProp":true,"id":["_uniq",21159]},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",26458],"binderInfo":"default"},{"type":"P.intervals.card = N","name":["hcard"],"isProp":true,"id":["_uniq",26467],"binderInfo":"default"},{"type":"∀ J ∈ P.intervals, J.length = (b - a) / (↑N : ℝ)","name":["hlength"],"isProp":true,"id":["_uniq",26471],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",94592],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",94595],"binderInfo":"default"},{"value":"Eq.mpr (id Set.image_nonempty._simp_1)\n  (Classical.byContradiction fun h =>\n    have h :=\n      of_eq_true\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => Subsingleton (↑x : Type))\n              (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑J : Set ℝ)) h))\n            (Set.subsingleton_coe._simp_1 ∅))\n          Set.subsingleton_empty._simp_1);\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑N : ℝ)⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left b (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                            (Mathlib.Tactic.Ring.mul_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                              (Mathlib.Tactic.Ring.mul_zero (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right a (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ)⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0))))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (b ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                          (a ^ Nat.rawCast 1 * ((↑N : ℝ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯))\n                  ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"(f '' (↑J : Set ℝ)).Nonempty","name":["hJnon"],"isProp":true,"id":["_uniq",126487]},{"value":"le_csInf hJnon\n  (integ_of_uniform_cts._proof_6 hfbound hsing hsing' ε hε δ hδ hf N hN hNpos hN' P hcard hlength J hJ hJnon\n    _fvar.135806)","type":"sSup (f '' (↑J : Set ℝ)) - ε ≤ sInf (f '' (↑J : Set ℝ))","name":["this"],"isProp":true,"id":["_uniq",147147]}]}],"start":3060},{"state":[],"start":3077},{"state":[],"start":3154},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",6520],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]}]}],"start":3197},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","_@","_hyg",87],"mvarId":["_uniq",179831],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]}]}],"start":3316},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","inl","_@","_hyg",87],"mvarId":["_uniq",180638],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]},{"type":"0 < upper_integral f I - lower_integral f I","name":["h"],"isProp":true,"id":["_uniq",180637],"binderInfo":"default"}]},{"type":"lower_integral f I = upper_integral f I","tag":["neg","inr","_@","_hyg",87],"mvarId":["_uniq",180643],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]},{"type":"0 = upper_integral f I - lower_integral f I","name":["h"],"isProp":true,"id":["_uniq",180642],"binderInfo":"default"}]}],"start":3368},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","inl","_@","_hyg",87],"mvarId":["_uniq",180841],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]},{"type":"0 < upper_integral f I - lower_integral f I","name":["h"],"isProp":true,"id":["_uniq",180637],"binderInfo":"default"},{"value":"(upper_integral f I - lower_integral f I) / (2 * (b - a))","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",180840]}]}],"start":3434},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (upper_integral f I - lower_integral f I) / 2","tag":[],"mvarId":["_uniq",181077],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]},{"type":"0 < upper_integral f I - lower_integral f I","name":["h"],"isProp":true,"id":["_uniq",180637],"binderInfo":"default"},{"value":"(upper_integral f I - lower_integral f I) / (2 * (b - a))","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",180840]}]}],"start":3542},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","inl","_@","_hyg",87],"mvarId":["_uniq",196647],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]},{"type":"0 < upper_integral f I - lower_integral f I","name":["h"],"isProp":true,"id":["_uniq",180637],"binderInfo":"default"},{"value":"(upper_integral f I - lower_integral f I) / (2 * (b - a))","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",180840]},{"type":"upper_integral f I - lower_integral f I ≤ (upper_integral f I - lower_integral f I) / 2","name":["this"],"isProp":true,"id":["_uniq",181078]}]}],"start":3595},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["neg","inr","_@","_hyg",87],"mvarId":["_uniq",180643],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",236],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",237],"binderInfo":"implicit"},{"type":"UniformContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",238],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (BddOn.iff' f (↑I : Set ℝ)))))\n  (UniformContinuousOn.of_bounded hf subset_rfl (Bornology.IsBounded.of_boundedInterval I))","type":"BddOn f (↑I : Set ℝ)","name":["hfbound"],"isProp":true,"id":["_uniq",329]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",5555]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",5638]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",5679],"binderInfo":"default"},{"value":"lt_of_not_ge fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hsing)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)))","type":"0 < b - a","name":["hsing'"],"isProp":true,"id":["_uniq",5828]},{"value":"fun ε hε =>\n  (fun δ x =>\n      (fun N hN =>\n          have hNpos :=\n            have this := div_pos hsing' x.left;\n            Eq.mpr\n              (id\n                (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n                  (Eq.trans\n                    (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                      (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                    (Eq.trans\n                      (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                        (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                      (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n              (Decidable.byContradiction fun a =>\n                ne_of_lt hN\n                  (le_antisymm (le_trans (le_of_lt hN) (le_refl (↑N : ℝ)))\n                    (le_trans (le_of_not_gt a) (le_trans (le_of_lt this) (le_refl ((I.b - I.a) / δ))))));\n          have hN' :=\n            Eq.mpr (id (congrArg (fun _a => _a) (propext (div_lt_comm₀ (Nat.cast_pos'.mpr hNpos) x.left)))) hN;\n          have this := sorry;\n          (fun P x_1 =>\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (have h1 := upper_integ_le_upper_sum hfbound P;\n                    have h2 := lower_integ_ge_lower_sum hfbound P;\n                    Eq.mpr\n                      (id\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg (LE.le (upper_integral f I - lower_integral f I))\n                              (Eq.trans\n                                (Finset.sum_congr (Eq.refl P.intervals) fun x a =>\n                                  sub_mul (sSup (f '' (↑x : Set ℝ))) (sInf (f '' (↑x : Set ℝ))) x.length)\n                                (Finset.sum_sub_distrib (fun x => sSup (f '' (↑x : Set ℝ)) * x.length) fun x =>\n                                  sInf (f '' (↑x : Set ℝ)) * x.length)))\n                            tsub_le_iff_right._simp_1)\n                          ge_iff_le._simp_1))\n                      (le_of_not_gt fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul\n                                            (∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                                          (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            ((∑ J ∈ P.intervals, sSup (f '' (↑J : Set ℝ)) * J.length) ^ Nat.rawCast 1 *\n                                                (Int.negOfNat 1).rawCast +\n                                              0)))))\n                                    (Mathlib.Tactic.Ring.sub_congr\n                                      (Mathlib.Tactic.Ring.atom_pf\n                                        (∑ J ∈ P.intervals, sInf (f '' (↑J : Set ℝ)) * J.length))\n                                      (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯) ⋯))\n                                    ⋯)\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ ε * (b - a)","name":["this"],"isProp":true,"id":["_uniq",6517]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral f I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral f I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hfbound))))","type":"0 ≤ upper_integral f I - lower_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",179830]},{"type":"0 = upper_integral f I - lower_integral f I","name":["h"],"isProp":true,"id":["_uniq",180642],"binderInfo":"default"}]}],"start":3608},{"state":[],"start":3619},{"state":[],"start":3620},{"state":[],"start":3644},{"state":[],"start":3724},{"state":[],"start":3816},{"state":[],"start":3817},{"state":[],"start":3882},{"state":[],"start":3883},{"state":[],"start":3951},{"state":[],"start":3952},{"state":[],"start":3991},{"state":[],"start":4026},{"state":[],"start":4051},{"state":[],"start":4133},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",200615],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"}]}],"start":4183},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",200615],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"}]}],"start":4256},{"state":[{"type":"IntegrableOn f I","tag":["pos","_@","_hyg",1794],"mvarId":["_uniq",200677],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"type":"I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",200676],"binderInfo":"default"}]},{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",200684],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"type":"¬I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",200683],"binderInfo":"default"}]}],"start":4286},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",200684],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"type":"¬I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",200683],"binderInfo":"default"}]}],"start":4328},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",200798],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"type":"¬I.length = 0","name":["hsing"],"isProp":true,"id":["_uniq",200683],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) hsing))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]}]}],"start":4445},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",207367],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"type":"I.a < I.b","name":["hsing"],"isProp":true,"id":["_uniq",207364],"binderInfo":"default"}]}],"start":4461},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",207417],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"type":"a < I.b","name":["hsing"],"isProp":true,"id":["_uniq",207414],"binderInfo":"default"}]}],"start":4476},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",207509],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"}]}],"start":4491},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",207574],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]}]}],"start":4547},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",207629],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"}]}],"start":4578},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",208243],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]}]}],"start":4650},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",208786],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"}]}],"start":4745},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":["inr"],"mvarId":["_uniq",208983],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",208956],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"}]}],"start":4774},{"state":[{"type":"BddOn f (↑I : Set ℝ)","tag":["inr","specialize_1"],"mvarId":["_uniq",208987],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"ContinuousOn f (↑I : Set ℝ)","tag":["inr","specialize_2"],"mvarId":["_uniq",208988],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"(↑I : Set ℝ).Nonempty","tag":["inr","specialize_3"],"mvarId":["_uniq",208989],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"I.a < I.b","tag":["inr","specialize_4"],"mvarId":["_uniq",208990],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"lower_integral f I ≤ upper_integral f I","tag":["inr","specialize_5"],"mvarId":["_uniq",208991],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"0 ≤ M","tag":["inr","specialize_6"],"mvarId":["_uniq",209013],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"(b - a) / 3 > 0","tag":["inr","specialize_7"],"mvarId":["_uniq",209109],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"(b - a) / 3 < (I.b - I.a) / 2","tag":["inr","specialize_8"],"mvarId":["_uniq",209110],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"∀ {I : BoundedInterval} {f : ℝ → ℝ},\n  BddOn f (↑I : Set ℝ) →\n    ContinuousOn f (↑I : Set ℝ) →\n      (↑I : Set ℝ).Nonempty →\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          lower_integral f I ≤ upper_integral f I →\n            ∀ (M : ℝ),\n              (∀ x ∈ (↑I : Set ℝ), |f x| ≤ M) →\n                0 ≤ M → ∀ ε > 0, ε < (b - a) / 2 → upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208907],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"}]},{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":["inr"],"mvarId":["_uniq",209133],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208512],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208544],"binderInfo":"default"},{"type":"¬ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208982],"binderInfo":"default"},{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ((b - a) / 3)","name":["this"],"isProp":true,"id":["_uniq",209130],"binderInfo":"default"}]}],"start":4827},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",208956],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"}]}],"start":4906},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",228660],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]}]}],"start":4938},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",229932],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]}]}],"start":4986},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",229932],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]}]}],"start":5018},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",229932],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]}]}],"start":5050},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",229932],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]}]}],"start":5082},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",229932],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]}]}],"start":5114},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",231439],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]}]}],"start":5163},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",231439],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]}]}],"start":5195},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",231439],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]}]}],"start":5227},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",231439],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]}]}],"start":5259},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",231439],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]}]}],"start":5291},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",232909],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]}]}],"start":5340},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",232909],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]}]}],"start":5372},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",232909],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]}]}],"start":5404},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",232909],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]}]}],"start":5436},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",232909],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]}]}],"start":5468},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",233418],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]}]}],"start":5557},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",237421],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]}]}],"start":5649},{"state":[{"type":"Ileft'.joins Ileft I'","tag":[],"mvarId":["_uniq",241487],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]}]}],"start":5695},{"state":[{"type":"Ileft'.joins Ileft I'","tag":["Ioo"],"mvarId":["_uniq",241571],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241519],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241520],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241554],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241555],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241556],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241557]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241558]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241559],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241560],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241561],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241562],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241563]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241564]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241565]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241566]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241567],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241568],"binderInfo":"default"}]},{"type":"Ileft'.joins Ileft I'","tag":["Icc"],"mvarId":["_uniq",241625],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241573],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241574],"binderInfo":"default"},{"type":"BddOn f (↑(Icc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241608],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Icc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241609],"binderInfo":"default"},{"type":"(↑(Icc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241610],"binderInfo":"default"},{"value":"(Icc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241611]},{"value":"(Icc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241612]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241613],"binderInfo":"default"},{"type":"lower_integral f (Icc a✝ b✝) ≤ upper_integral f (Icc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241614],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Icc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241615],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241616],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241617]},{"value":"match Icc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241618]},{"value":"match Icc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241619]},{"value":"match Icc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241620]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241621],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241622],"binderInfo":"default"}]},{"type":"Ileft'.joins Ileft I'","tag":["Ioc"],"mvarId":["_uniq",241679],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241627],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241628],"binderInfo":"default"},{"type":"BddOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241662],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241663],"binderInfo":"default"},{"type":"(↑(Ioc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241664],"binderInfo":"default"},{"value":"(Ioc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241665]},{"value":"(Ioc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241666]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241667],"binderInfo":"default"},{"type":"lower_integral f (Ioc a✝ b✝) ≤ upper_integral f (Ioc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241668],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241669],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241670],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241671]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241672]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241673]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241674]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241675],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241676],"binderInfo":"default"}]},{"type":"Ileft'.joins Ileft I'","tag":["Ico"],"mvarId":["_uniq",241733],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241681],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241682],"binderInfo":"default"},{"type":"BddOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241716],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241717],"binderInfo":"default"},{"type":"(↑(Ico a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241718],"binderInfo":"default"},{"value":"(Ico a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241719]},{"value":"(Ico a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241720]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241721],"binderInfo":"default"},{"type":"lower_integral f (Ico a✝ b✝) ≤ upper_integral f (Ico a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241722],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ico a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241723],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241724],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241725]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241726]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241727]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241728]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241729],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241730],"binderInfo":"default"}]}],"start":5709},{"state":[{"type":"Ileft'.joins Ileft I'","tag":["Ioo"],"mvarId":["_uniq",241571],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241519],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241520],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241554],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241555],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241556],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241557]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241558]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241559],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241560],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241561],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241562],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241563]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241564]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241565]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241566]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241567],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241568],"binderInfo":"default"}]},{"type":"Ileft'.joins Ileft I'","tag":["Ioc"],"mvarId":["_uniq",241679],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241627],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241628],"binderInfo":"default"},{"type":"BddOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241662],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241663],"binderInfo":"default"},{"type":"(↑(Ioc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241664],"binderInfo":"default"},{"value":"(Ioc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241665]},{"value":"(Ioc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241666]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241667],"binderInfo":"default"},{"type":"lower_integral f (Ioc a✝ b✝) ≤ upper_integral f (Ioc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241668],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241669],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241670],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241671]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241672]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241673]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241674]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241675],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241676],"binderInfo":"default"}]},{"type":"Ileft'.joins Ileft I'","tag":["Ico"],"mvarId":["_uniq",241733],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241681],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241682],"binderInfo":"default"},{"type":"BddOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241716],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241717],"binderInfo":"default"},{"type":"(↑(Ico a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241718],"binderInfo":"default"},{"value":"(Ico a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241719]},{"value":"(Ico a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241720]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241721],"binderInfo":"default"},{"type":"lower_integral f (Ico a✝ b✝) ≤ upper_integral f (Ico a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241722],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ico a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241723],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241724],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241725]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241726]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241727]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241728]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241729],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241730],"binderInfo":"default"}]}],"start":5763},{"state":[{"type":"Ileft'.joins Ileft I'","tag":["Ioo"],"mvarId":["_uniq",241571],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241519],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241520],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241554],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241555],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241556],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241557]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241558]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241559],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241560],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241561],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241562],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241563]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241564]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241565]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241566]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241567],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241568],"binderInfo":"default"}]},{"type":"Ileft'.joins Ileft I'","tag":["Ioc"],"mvarId":["_uniq",241679],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241627],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241628],"binderInfo":"default"},{"type":"BddOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241662],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241663],"binderInfo":"default"},{"type":"(↑(Ioc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241664],"binderInfo":"default"},{"value":"(Ioc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241665]},{"value":"(Ioc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241666]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241667],"binderInfo":"default"},{"type":"lower_integral f (Ioc a✝ b✝) ≤ upper_integral f (Ioc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241668],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241669],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241670],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241671]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241672]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241673]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241674]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241675],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241676],"binderInfo":"default"}]}],"start":5817},{"state":[{"type":"Ileft'.joins Ileft I'","tag":["Ioo"],"mvarId":["_uniq",241571],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",241519],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",241520],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",241554],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",241555],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",241556],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",241557]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",241558]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",241559],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",241560],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",241561],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",241562],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",241563]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",241564]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",241565]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",241566]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",241567],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",241568],"binderInfo":"default"}]}],"start":5871},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",241489],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]}]}],"start":5925},{"state":[{"type":"I.joins Ileft' Iright","tag":[],"mvarId":["_uniq",251704],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]}]}],"start":5970},{"state":[{"type":"(Ioo a✝ b✝).joins Ileft' Iright","tag":["Ioo"],"mvarId":["_uniq",251790],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251736],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251737],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251772],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251773],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251774],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251775]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251776]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251777],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251778],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251779],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251780],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251781]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251782]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251783]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251784]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251785],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251786],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251787],"binderInfo":"default"}]},{"type":"(Icc a✝ b✝).joins Ileft' Iright","tag":["Icc"],"mvarId":["_uniq",251846],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251792],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251793],"binderInfo":"default"},{"type":"BddOn f (↑(Icc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251828],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Icc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251829],"binderInfo":"default"},{"type":"(↑(Icc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251830],"binderInfo":"default"},{"value":"(Icc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251831]},{"value":"(Icc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251832]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251833],"binderInfo":"default"},{"type":"lower_integral f (Icc a✝ b✝) ≤ upper_integral f (Icc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251834],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Icc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251835],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251836],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251837]},{"value":"match Icc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251838]},{"value":"match Icc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251839]},{"value":"match Icc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251840]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251841],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251842],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251843],"binderInfo":"default"}]},{"type":"(Ioc a✝ b✝).joins Ileft' Iright","tag":["Ioc"],"mvarId":["_uniq",251902],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251848],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251849],"binderInfo":"default"},{"type":"BddOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251884],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251885],"binderInfo":"default"},{"type":"(↑(Ioc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251886],"binderInfo":"default"},{"value":"(Ioc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251887]},{"value":"(Ioc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251888]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251889],"binderInfo":"default"},{"type":"lower_integral f (Ioc a✝ b✝) ≤ upper_integral f (Ioc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251890],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251891],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251892],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251893]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251894]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251895]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251896]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251897],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251898],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251899],"binderInfo":"default"}]},{"type":"(Ico a✝ b✝).joins Ileft' Iright","tag":["Ico"],"mvarId":["_uniq",251958],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251904],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251905],"binderInfo":"default"},{"type":"BddOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251940],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251941],"binderInfo":"default"},{"type":"(↑(Ico a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251942],"binderInfo":"default"},{"value":"(Ico a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251943]},{"value":"(Ico a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251944]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251945],"binderInfo":"default"},{"type":"lower_integral f (Ico a✝ b✝) ≤ upper_integral f (Ico a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251946],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ico a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251947],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251948],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251949]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251950]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251951]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251952]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251953],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251954],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251955],"binderInfo":"default"}]}],"start":5984},{"state":[{"type":"(Ioo a✝ b✝).joins Ileft' Iright","tag":["Ioo"],"mvarId":["_uniq",251790],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251736],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251737],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251772],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251773],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251774],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251775]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251776]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251777],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251778],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251779],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251780],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251781]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251782]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251783]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251784]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251785],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251786],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251787],"binderInfo":"default"}]},{"type":"(Ioc a✝ b✝).joins Ileft' Iright","tag":["Ioc"],"mvarId":["_uniq",251902],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251848],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251849],"binderInfo":"default"},{"type":"BddOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251884],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251885],"binderInfo":"default"},{"type":"(↑(Ioc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251886],"binderInfo":"default"},{"value":"(Ioc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251887]},{"value":"(Ioc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251888]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251889],"binderInfo":"default"},{"type":"lower_integral f (Ioc a✝ b✝) ≤ upper_integral f (Ioc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251890],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251891],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251892],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251893]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251894]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251895]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251896]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251897],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251898],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251899],"binderInfo":"default"}]},{"type":"(Ico a✝ b✝).joins Ileft' Iright","tag":["Ico"],"mvarId":["_uniq",251958],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251904],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251905],"binderInfo":"default"},{"type":"BddOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251940],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ico a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251941],"binderInfo":"default"},{"type":"(↑(Ico a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251942],"binderInfo":"default"},{"value":"(Ico a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251943]},{"value":"(Ico a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251944]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251945],"binderInfo":"default"},{"type":"lower_integral f (Ico a✝ b✝) ≤ upper_integral f (Ico a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251946],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ico a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251947],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251948],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251949]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251950]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251951]},{"value":"match Ico a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251952]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251953],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251954],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251955],"binderInfo":"default"}]}],"start":6038},{"state":[{"type":"(Ioo a✝ b✝).joins Ileft' Iright","tag":["Ioo"],"mvarId":["_uniq",251790],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251736],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251737],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251772],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251773],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251774],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251775]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251776]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251777],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251778],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251779],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251780],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251781]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251782]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251783]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251784]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251785],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251786],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251787],"binderInfo":"default"}]},{"type":"(Ioc a✝ b✝).joins Ileft' Iright","tag":["Ioc"],"mvarId":["_uniq",251902],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251848],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251849],"binderInfo":"default"},{"type":"BddOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251884],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioc a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251885],"binderInfo":"default"},{"type":"(↑(Ioc a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251886],"binderInfo":"default"},{"value":"(Ioc a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251887]},{"value":"(Ioc a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251888]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251889],"binderInfo":"default"},{"type":"lower_integral f (Ioc a✝ b✝) ≤ upper_integral f (Ioc a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251890],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioc a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251891],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251892],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251893]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251894]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251895]},{"value":"match Ioc a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251896]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251897],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251898],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251899],"binderInfo":"default"}]}],"start":6092},{"state":[{"type":"(Ioo a✝ b✝).joins Ileft' Iright","tag":["Ioo"],"mvarId":["_uniq",251790],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ℝ","name":["a✝"],"isProp":false,"id":["_uniq",251736],"binderInfo":"default"},{"type":"ℝ","name":["b✝"],"isProp":false,"id":["_uniq",251737],"binderInfo":"default"},{"type":"BddOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",251772],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Ioo a✝ b✝) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",251773],"binderInfo":"default"},{"type":"(↑(Ioo a✝ b✝) : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",251774],"binderInfo":"default"},{"value":"(Ioo a✝ b✝).a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",251775]},{"value":"(Ioo a✝ b✝).b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",251776]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",251777],"binderInfo":"default"},{"type":"lower_integral f (Ioo a✝ b✝) ≤ upper_integral f (Ioo a✝ b✝)","name":["lower_le_upper"],"isProp":true,"id":["_uniq",251778],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Ioo a✝ b✝) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",251779],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",251780],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",251781]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",251782]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",251783]},{"value":"match Ioo a✝ b✝, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",251784]},{"type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",251785],"binderInfo":"default"},{"type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",251786],"binderInfo":"default"},{"type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",251787],"binderInfo":"default"}]}],"start":6146},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",251706],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]}]}],"start":6200},{"state":[{"type":"IntegrableOn f I'","tag":[],"mvarId":["_uniq",261920],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]}]}],"start":6239},{"state":[{"type":"(↑(Icc (a + ε) (b - ε)) : Set ℝ) ⊆ (↑(Ioo I.a I.b) : Set ℝ)","tag":[],"mvarId":["_uniq",262102],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]}]}],"start":6341},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",261922],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]}]}],"start":6368},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",303007],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"}]}],"start":6502},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",303007],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"}]}],"start":6516},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",303046],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]}]}],"start":6582},{"state":[{"type":"h' x = M","tag":[],"mvarId":["_uniq",303425],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",303355],"binderInfo":"default"},{"type":"x ∈ Ileft","name":["hx"],"isProp":true,"id":["_uniq",303421],"binderInfo":"default"}]}],"start":6647},{"state":[{"type":"h' x = M","tag":[],"mvarId":["_uniq",303456],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen\n            _fvar.241488 hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",303355],"binderInfo":"default"},{"type":"x ∈ Ileft","name":["hx"],"isProp":true,"id":["_uniq",303421],"binderInfo":"default"},{"type":"x ∉ (↑Ileft : Set ℝ) ∩ (↑I' : Set ℝ)","name":["hjoin1"],"isProp":true,"id":["_uniq",303452]}]}],"start":6716},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",303428],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]}]}],"start":6744},{"state":[{"type":"h' x = M","tag":[],"mvarId":["_uniq",317703],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",317623],"binderInfo":"default"},{"type":"x ∈ Iright","name":["hx"],"isProp":true,"id":["_uniq",317699],"binderInfo":"default"}]}],"start":6811},{"state":[{"type":"h' x = M","tag":[],"mvarId":["_uniq",317734],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            _fvar.251705))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",317623],"binderInfo":"default"},{"type":"x ∈ Iright","name":["hx"],"isProp":true,"id":["_uniq",317699],"binderInfo":"default"},{"type":"x ∉ (↑Ileft' : Set ℝ) ∩ (↑Iright : Set ℝ)","name":["hjoin2"],"isProp":true,"id":["_uniq",317730]}]}],"start":6880},{"state":[{"type":"h' x = M","tag":[],"mvarId":["_uniq",317949],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen\n            _fvar.241488 _fvar.251705))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",317623],"binderInfo":"default"},{"type":"x ∈ Iright","name":["hx"],"isProp":true,"id":["_uniq",317699],"binderInfo":"default"},{"type":"x ∉ (↑Ileft' : Set ℝ) ∩ (↑Iright : Set ℝ)","name":["hjoin2"],"isProp":true,"id":["_uniq",317730]},{"type":"(fun x_1 => x ∈ x_1) (↑Ileft' : Set ℝ) = (fun x_1 => x ∈ x_1) ((↑Ileft : Set ℝ) ∪ (↑I' : Set ℝ))","name":["hjoin1"],"isProp":true,"id":["_uniq",317936]}]}],"start":6935},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",317706],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]}],"start":6963},{"state":[{"type":"PiecewiseConstantOn h' I","tag":[],"mvarId":["_uniq",335149],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]}],"start":7013},{"state":[{"type":"PiecewiseConstantOn h' Ileft","tag":["refine_1","refine_1"],"mvarId":["_uniq",335305],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]},{"type":"PiecewiseConstantOn h' I'","tag":["refine_1","refine_2"],"mvarId":["_uniq",335306],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]},{"type":"PiecewiseConstantOn h' Iright","tag":["refine_2"],"mvarId":["_uniq",335300],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]}],"start":7067},{"state":[{"type":"PiecewiseConstantOn h' I'","tag":["refine_1","refine_2"],"mvarId":["_uniq",335306],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]},{"type":"PiecewiseConstantOn h' Iright","tag":["refine_2"],"mvarId":["_uniq",335300],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]}],"start":7119},{"state":[{"type":"PiecewiseConstantOn h' Iright","tag":["refine_2"],"mvarId":["_uniq",335300],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]}]}],"start":7165},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",335151],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]}]}],"start":7215},{"state":[{"type":"MajorizesOn h' f I","tag":[],"mvarId":["_uniq",377655],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]}]}],"start":7257},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",377659],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj"],"isProp":true,"id":["_uniq",377656]}]}],"start":7350},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",476734],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"}]}],"start":7408},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",476758],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]}]}],"start":7458},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",476786],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]}]}],"start":7534},{"state":[{"type":"PiecewiseConstantOn.integ h' Ileft = M * ε","tag":[],"mvarId":["_uniq",476842],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]}]}],"start":7604},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",476844],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]}]}],"start":7683},{"state":[{"type":"PiecewiseConstantOn.integ h' Iright = M * ε","tag":[],"mvarId":["_uniq",477006],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]}]}],"start":7754},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",477008],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]}]}],"start":7835},{"state":[{"type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","tag":[],"mvarId":["_uniq",477094],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]}]}],"start":7926},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",477096],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]}]}],"start":7987},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",553609],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"}]}],"start":8121},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",553653],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]}]}],"start":8188},{"state":[{"type":"g' x = -M","tag":[],"mvarId":["_uniq",554185],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",554112],"binderInfo":"default"},{"type":"x ∈ Ileft","name":["hx"],"isProp":true,"id":["_uniq",554178],"binderInfo":"default"}]}],"start":8254},{"state":[{"type":"g' x = -M","tag":[],"mvarId":["_uniq",554216],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen\n            _fvar.241488 hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join _fvar.241488 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen\n            _fvar.241488 hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen _fvar.241488\n        hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join _fvar.241488 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen _fvar.241488\n    hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n    h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",554112],"binderInfo":"default"},{"type":"x ∈ Ileft","name":["hx"],"isProp":true,"id":["_uniq",554178],"binderInfo":"default"},{"type":"x ∉ (↑Ileft : Set ℝ) ∩ (↑I' : Set ℝ)","name":["hjoin1"],"isProp":true,"id":["_uniq",554212]}]}],"start":8323},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",554188],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]}]}],"start":8352},{"state":[{"type":"g' x = -M","tag":[],"mvarId":["_uniq",580332],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",580242],"binderInfo":"default"},{"type":"x ∈ Iright","name":["hx"],"isProp":true,"id":["_uniq",580318],"binderInfo":"default"}]}],"start":8420},{"state":[{"type":"g' x = -M","tag":[],"mvarId":["_uniq",580363],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            _fvar.251705))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join _fvar.251705 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            _fvar.251705 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n        _fvar.251705 hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join _fvar.251705 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join _fvar.251705 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n    _fvar.251705 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n    h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",580242],"binderInfo":"default"},{"type":"x ∈ Iright","name":["hx"],"isProp":true,"id":["_uniq",580318],"binderInfo":"default"},{"type":"x ∉ (↑Ileft' : Set ℝ) ∩ (↑Iright : Set ℝ)","name":["hjoin2"],"isProp":true,"id":["_uniq",580359]}]}],"start":8489},{"state":[{"type":"g' x = -M","tag":[],"mvarId":["_uniq",580578],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen\n            _fvar.241488 _fvar.251705))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join _fvar.251705 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join _fvar.241488 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen\n            _fvar.241488 _fvar.251705 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen _fvar.241488\n        _fvar.251705 hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join _fvar.251705 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join _fvar.241488 ((of_join _fvar.251705 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen _fvar.241488\n    _fvar.251705 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n    h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",580242],"binderInfo":"default"},{"type":"x ∈ Iright","name":["hx"],"isProp":true,"id":["_uniq",580318],"binderInfo":"default"},{"type":"x ∉ (↑Ileft' : Set ℝ) ∩ (↑Iright : Set ℝ)","name":["hjoin2"],"isProp":true,"id":["_uniq",580359]},{"type":"(fun x_1 => x ∈ x_1) (↑Ileft' : Set ℝ) = (fun x_1 => x ∈ x_1) ((↑Ileft : Set ℝ) ∪ (↑I' : Set ℝ))","name":["hjoin1"],"isProp":true,"id":["_uniq",580565]}]}],"start":8544},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",580335],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]}],"start":8573},{"state":[{"type":"PiecewiseConstantOn g' I","tag":[],"mvarId":["_uniq",609682],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]}],"start":8623},{"state":[{"type":"PiecewiseConstantOn g' Ileft","tag":["refine_1","refine_1"],"mvarId":["_uniq",609838],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]},{"type":"PiecewiseConstantOn g' I'","tag":["refine_1","refine_2"],"mvarId":["_uniq",609839],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]},{"type":"PiecewiseConstantOn g' Iright","tag":["refine_2"],"mvarId":["_uniq",609833],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]}],"start":8677},{"state":[{"type":"PiecewiseConstantOn g' I'","tag":["refine_1","refine_2"],"mvarId":["_uniq",609839],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]},{"type":"PiecewiseConstantOn g' Iright","tag":["refine_2"],"mvarId":["_uniq",609833],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]}],"start":8729},{"state":[{"type":"PiecewiseConstantOn g' Iright","tag":["refine_2"],"mvarId":["_uniq",609833],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]}]}],"start":8775},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",609684],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]}]}],"start":8825},{"state":[{"type":"MinorizesOn g' f I","tag":[],"mvarId":["_uniq",695152],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]}]}],"start":8867},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",695156],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj"],"isProp":true,"id":["_uniq",695153]}]}],"start":8960},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",787671],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"}]}],"start":9018},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",787695],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]}]}],"start":9068},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",787723],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]}]}],"start":9144},{"state":[{"type":"PiecewiseConstantOn.integ g' Ileft = -M * ε","tag":[],"mvarId":["_uniq",787789],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]}]}],"start":9215},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",787791],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Ileftlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Ileft = -M * ε","name":["g'integ3"],"isProp":true,"id":["_uniq",787790]}]}],"start":9294},{"state":[{"type":"PiecewiseConstantOn.integ g' Iright = -M * ε","tag":[],"mvarId":["_uniq",787956],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Ileftlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Ileft = -M * ε","name":["g'integ3"],"isProp":true,"id":["_uniq",787790]}]}],"start":9366},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",787958],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Ileftlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Ileft = -M * ε","name":["g'integ3"],"isProp":true,"id":["_uniq",787790]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Iright)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Irightlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Iright = -M * ε","name":["g'integ4"],"isProp":true,"id":["_uniq",787957]}]}],"start":9447},{"state":[{"type":"PiecewiseConstantOn.integ g' I' = PiecewiseConstantOn.integ g I'","tag":[],"mvarId":["_uniq",788044],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Ileftlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Ileft = -M * ε","name":["g'integ3"],"isProp":true,"id":["_uniq",787790]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Iright)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Irightlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Iright = -M * ε","name":["g'integ4"],"isProp":true,"id":["_uniq",787957]}]}],"start":9538},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","tag":[],"mvarId":["_uniq",788046],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",208937],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",208938],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",208939],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",208940],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",208941],"binderInfo":"default"},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",208942]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",208943]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",208944],"binderInfo":"default"},{"type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",208945],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",208946],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",208947],"binderInfo":"default"},{"type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208948],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",208949],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",208950],"binderInfo":"default"},{"type":"ε < (b - a) / 2","name":["hε'"],"isProp":true,"id":["_uniq",208955],"binderInfo":"default"},{"value":"Icc (a + ε) (b - ε)","type":"BoundedInterval","name":["I'"],"isProp":false,"id":["_uniq",228659]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n| Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n| Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)","type":"BoundedInterval","name":["Ileft"],"isProp":false,"id":["_uniq",229931]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n| Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n| Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b","type":"BoundedInterval","name":["Iright"],"isProp":false,"id":["_uniq",231438]},{"value":"match I, hbound, hf, hI, lower_le_upper, hM with\n| Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n| Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n| Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)","type":"BoundedInterval","name":["Ileft'"],"isProp":false,"id":["_uniq",232908]},{"value":"casesOn (motive := fun t => I = t → Ileft.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε)) (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : ⋯) (hf : ⋯) (hI : ⋯),\n        let a := I.a;\n        let b := I.b;\n        ⋯ →\n          ∀ (lower_le_upper : ⋯) (hM : ⋯),\n            ⋯ →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => Icc a (b - ε)\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯\n                | ⋯, ⋯, ⋯, ⋯, ⋯, ⋯ => ⋯;\n              ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Ileft.length = ε","name":["Ileftlen"],"isProp":true,"id":["_uniq",233417]},{"value":"casesOn (motive := fun t => I = t → Iright.length = ε) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioo (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Icc a b).a;\n        let b_1 := (Icc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (fun x => x = ε)\n              (Eq.trans (congrArg (fun x => Max.max x 0) (sub_sub_cancel (Ioc (b_1 - ε) b_1).b ε))\n                (sup_of_le_left (le_of_lt hε))))\n            (eq_self ε)))\n      (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε' Ileftlen)\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε)\n      (fun hbound hf hI =>\n        let a_1 := (Ioc a b).a;\n        let b_1 := (Ioc a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioc a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen => of_eq_true (Eq.trans (congrArg (fun x => x = ε) (Eq.trans ⋯ ⋯)) ⋯))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯","type":"Iright.length = ε","name":["Irightlen"],"isProp":true,"id":["_uniq",237420]},{"value":"casesOn (motive := fun t => I = t → Ileft'.joins Ileft I') I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I')\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen =>\n        join_Ioo_Icc\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a_1) (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf a_1)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero a_1 (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf b_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf a_1)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯)))\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"Ileft'.joins Ileft I'","name":["hjoin1"],"isProp":true,"id":["_uniq",241488]},{"value":"casesOn (motive := fun t => I = t → I.joins Ileft' Iright) I\n  (fun a b h =>\n    Eq.ndrec (motive := fun {I} =>\n      ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n        let a := I.a;\n        let b := I.b;\n        a < b →\n          ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n            ε < (b - a) / 2 →\n              let I' := Icc (a + ε) (b - ε);\n              let Ileft :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n              let Iright :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n              let Ileft' :=\n                match I, hbound, hf, hI, lower_le_upper, hM with\n                | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n              Ileft.length = ε → Iright.length = ε → Ileft'.joins Ileft I' → I.joins Ileft' Iright)\n      (fun hbound hf hI =>\n        let a_1 := (Ioo a b).a;\n        let b_1 := (Ioo a b).b;\n        fun hsing lower_le_upper hM hε' =>\n        let I' := Icc (a_1 + ε) (b_1 - ε);\n        let Ileft :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n        let Iright :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n        let Ileft' :=\n          match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n          | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n          | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n          | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n        fun Ileftlen Irightlen hjoin1 =>\n        join_Ioc_Ioo\n          (le_of_not_gt fun a_2 =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf b_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right b_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf a_1)\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right a_1 (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (a_1 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (b_1 ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (a_1 ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul b_1 (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul a_1 (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯))\n                ⋯))\n          ⋯)\n      ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n  ⋯ ⋯ ⋯ ⋯","type":"I.joins Ileft' Iright","name":["hjoin2"],"isProp":true,"id":["_uniq",251705]},{"value":"integ_of_cts\n  (ContinuousOn.mono hf\n    (subset_trans\n      (fun ⦃a_1⦄ =>\n        Eq.mpr\n          (id\n            (Eq.trans\n              (implies_congr (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Icc (a + ε) (b - ε))) Set.mem_Icc._simp_1)\n                (Eq.trans (congrArg (fun x => a_1 ∈ x) (set_Ioo I.a I.b)) Set.mem_Ioo._simp_1))\n              and_imp._simp_1))\n          (integ_of_bdd_cts._proof_6 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2))\n      ((subset_iff (Ioo I.a I.b) I).mp (Ioo_subset I))))","type":"IntegrableOn f I'","name":["hf'"],"isProp":true,"id":["_uniq",261921]},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",302983],"binderInfo":"default"},{"type":"MajorizesOn h f I'","name":["hhmin"],"isProp":true,"id":["_uniq",302991],"binderInfo":"default"},{"type":"PiecewiseConstantOn h I'","name":["hhconst"],"isProp":true,"id":["_uniq",303002],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ h I' < integ f I' + ε","name":["hhint"],"isProp":true,"id":["_uniq",303006],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then h x else M","type":"ℝ → ℝ","name":["h'"],"isProp":false,"id":["_uniq",303045]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self M))","type":"∀ x ∈ Ileft, h' x = M","name":["h'const_left"],"isProp":true,"id":["_uniq",303427]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (h x)) fun a => Eq.refl M) x)\n          (ite_cond_eq_false (h x) M\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self M))","type":"∀ x ∈ Iright, h' x = M","name":["h'const_right"],"isProp":true,"id":["_uniq",317705]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 h'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn h' Iright) (propext (of_join hjoin1 h'))))\n    ⟨⟨piecewiseConstantOn (of_const h'const_left),\n        PiecewiseConstantOn.congr' hhconst\n          (integ_of_bdd_cts._proof_7 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right)⟩,\n      piecewiseConstantOn (of_const h'const_right)⟩)","type":"PiecewiseConstantOn h' I","name":["h'const"],"isProp":true,"id":["_uniq",335150]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_true (h x) M (eq_true hxI')))) (hhmin x hxI')\n  else\n    Eq.mpr (id (congrArg (LE.le (f x)) (ite_cond_eq_false (h x) M (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_8 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const x a hxI')","type":"MajorizesOn h' f I","name":["h'maj✝"],"isProp":true,"id":["_uniq",377656]},{"type":"upper_integral f I ≤ h'const.integ'","name":["h'maj"],"isProp":true,"id":["_uniq",476733],"binderInfo":"default"},{"value":"integ_of_join hjoin2 h'const","type":"PiecewiseConstantOn.integ h' I = PiecewiseConstantOn.integ h' Ileft' + PiecewiseConstantOn.integ h' Iright","name":["h'integ1"],"isProp":true,"id":["_uniq",476757]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 h').mp h'const).left","type":"PiecewiseConstantOn.integ h' Ileft' = PiecewiseConstantOn.integ h' Ileft + PiecewiseConstantOn.integ h' I'","name":["h'integ2"],"isProp":true,"id":["_uniq",476785]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Ileftlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Ileft = M * ε","name":["h'integ3"],"isProp":true,"id":["_uniq",476843]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = M * ε) (PiecewiseConstantOn.integ_congr h'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = M * ε) (integ_const M Iright)))\n    (Eq.mpr (id (congrArg (fun _a => M * _a = M * ε) Irightlen)) (Eq.refl (M * ε))))","type":"PiecewiseConstantOn.integ h' Iright = M * ε","name":["h'integ4"],"isProp":true,"id":["_uniq",477007]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_15 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4)","type":"PiecewiseConstantOn.integ h' I' = PiecewiseConstantOn.integ h I'","name":["h'integ5"],"isProp":true,"id":["_uniq",477095]},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",553585],"binderInfo":"default"},{"type":"MinorizesOn g f I'","name":["hgmin"],"isProp":true,"id":["_uniq",553593],"binderInfo":"default"},{"type":"PiecewiseConstantOn g I'","name":["hgconst"],"isProp":true,"id":["_uniq",553604],"binderInfo":"default"},{"type":"integ f I' - ε < PiecewiseConstantOn.integ g I'","name":["hgint"],"isProp":true,"id":["_uniq",553608],"binderInfo":"default"},{"value":"fun x => if x ∈ I' then g x else -M","type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",553652]},{"value":"fun x hx =>\n  have hjoin1 := Set.eq_empty_iff_forall_notMem.mp hjoin1.left x;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                (Eq.mp\n                  (congrArg Not\n                    (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))\n                      (Eq.trans\n                        (congrArg (fun x_1 => x_1 ∧ x ∈ (↑I' : Set ℝ))\n                          (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Ileft x) hx))))\n                        (true_and (x ∈ (↑I' : Set ℝ))))))\n                  hjoin1))))))\n      (eq_self (-M)))","type":"∀ x ∈ Ileft, g' x = -M","name":["g'const_left"],"isProp":true,"id":["_uniq",554187]},{"value":"fun x hx =>\n  have hjoin2 := Set.eq_empty_iff_forall_notMem.mp hjoin2.left x;\n  have hjoin1 := congrArg (fun x_1 => x ∈ x_1) hjoin1.right.left;\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x => x = -M)\n        (Eq.trans\n          (congrFun\n            (funext fun x => ite_congr (integ_of_bdd_cts._simp_6 I' x) (fun a => Eq.refl (g x)) fun a => Eq.refl (-M))\n            x)\n          (ite_cond_eq_false (g x) (-M)\n            (eq_false\n              (id\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans (Set.mem_inter_iff._simp_1 x (↑Ileft' : Set ℝ) (↑Iright : Set ℝ))\n                          (Eq.trans\n                            (_root_.congr\n                              (congrArg And (Eq.trans hjoin1 (Set.mem_union._simp_1 x (↑Ileft : Set ℝ) (↑I' : Set ℝ))))\n                              (eq_true (id (Eq.mp (integ_of_bdd_cts._simp_6 Iright x) hx))))\n                            (and_true (x ∈ (↑Ileft : Set ℝ) ∨ x ∈ (↑I' : Set ℝ))))))\n                      not_or._simp_1)\n                    hjoin2)).2))))\n      (eq_self (-M)))","type":"∀ x ∈ Iright, g' x = -M","name":["g'const_right"],"isProp":true,"id":["_uniq",580334]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (of_join hjoin2 g'))))\n  (Eq.mpr (id (congrArg (fun _a => _a ∧ PiecewiseConstantOn g' Iright) (propext (of_join hjoin1 g'))))\n    ⟨⟨piecewiseConstantOn (of_const g'const_left),\n        PiecewiseConstantOn.congr' hgconst\n          (integ_of_bdd_cts._proof_16 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1\n            hjoin2 hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3\n            h'integ4 h'integ5 g hgmin hgconst hgint g'const_left g'const_right)⟩,\n      piecewiseConstantOn (of_const g'const_right)⟩)","type":"PiecewiseConstantOn g' I","name":["g'const"],"isProp":true,"id":["_uniq",609683]},{"value":"fun x a =>\n  if hxI' : x ∈ I' then\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_true (g x) (-M) (eq_true hxI')))) (hgmin x hxI')\n  else\n    Eq.mpr (id (congrArg (fun x_1 => x_1 ≤ f x) (ite_cond_eq_false (g x) (-M) (eq_false hxI'))))\n      (integ_of_bdd_cts._proof_17 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2\n        hf' h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4\n        h'integ5 g hgmin hgconst hgint g'const_left g'const_right g'const x a hxI')","type":"MinorizesOn g' f I","name":["g'maj✝"],"isProp":true,"id":["_uniq",695153]},{"type":"g'const.integ' ≤ lower_integral f I","name":["g'maj"],"isProp":true,"id":["_uniq",787670],"binderInfo":"default"},{"value":"integ_of_join hjoin2 g'const","type":"PiecewiseConstantOn.integ g' I = PiecewiseConstantOn.integ g' Ileft' + PiecewiseConstantOn.integ g' Iright","name":["g'integ1"],"isProp":true,"id":["_uniq",787694]},{"value":"integ_of_join hjoin1 ((of_join hjoin2 g').mp g'const).left","type":"PiecewiseConstantOn.integ g' Ileft' = PiecewiseConstantOn.integ g' Ileft + PiecewiseConstantOn.integ g' I'","name":["g'integ2"],"isProp":true,"id":["_uniq",787722]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_left)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Ileft)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Ileftlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Ileft = -M * ε","name":["g'integ3"],"isProp":true,"id":["_uniq",787790]},{"value":"Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (PiecewiseConstantOn.integ_congr g'const_right)))\n  (Eq.mpr (id (congrArg (fun _a => _a = -M * ε) (integ_const (-M) Iright)))\n    (Eq.mpr (id (congrArg (fun _a => -M * _a = -M * ε) Irightlen)) (Eq.refl (-M * ε))))","type":"PiecewiseConstantOn.integ g' Iright = -M * ε","name":["g'integ4"],"isProp":true,"id":["_uniq",787957]},{"value":"PiecewiseConstantOn.integ_congr\n  (integ_of_bdd_cts._proof_24 hbound hf hI hsing lower_le_upper M hM hMpos ε hε hε' Ileftlen Irightlen hjoin1 hjoin2 hf'\n    h hhmin hhconst hhint h'const_left h'const_right h'const h'maj✝ h'maj h'integ1 h'integ2 h'integ3 h'integ4 h'integ5 g\n    hgmin hgconst hgint g'const_left g'const_right g'const g'maj✝ g'maj g'integ1 g'integ2 g'integ3 g'integ4)","type":"PiecewiseConstantOn.integ g' I' = PiecewiseConstantOn.integ g I'","name":["g'integ5"],"isProp":true,"id":["_uniq",788045]}]}],"start":9599},{"state":[{"type":"IntegrableOn f I","tag":["neg","_@","_hyg",1794],"mvarId":["_uniq",208791],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",200611],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",200612],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",200613],"binderInfo":"default"},{"type":"ContinuousOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",200614],"binderInfo":"default"},{"value":"Classical.byContradiction fun this =>\n  False.elim\n    (Eq.mp\n      (Eq.trans\n        (congrArg Not\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => Subsingleton (↑x : Type))\n                (Eq.mp (Mathlib.Tactic.PushNeg.not_nonempty_eq (↑I : Set ℝ)) this))\n              (Set.subsingleton_coe._simp_1 ∅))\n            Set.subsingleton_empty._simp_1))\n        not_true_eq_false)\n      (Eq.mp (congrArg (fun _a => ¬_a) (Eq.symm (propext length_of_subsingleton))) _fvar.200683))","type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",200797]},{"value":"I.a","type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",207370]},{"value":"I.b","type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",207465]},{"type":"a < b","name":["hsing"],"isProp":true,"id":["_uniq",207506],"binderInfo":"default"},{"value":"lower_integral_le_upper hbound","type":"lower_integral f I ≤ upper_integral f I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",207573]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",207620],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",207621],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M","name":["hMpos"],"isProp":true,"id":["_uniq",208242]},{"value":"fun ε hε =>\n  Or.casesOn (Classical.em (ε < (b - a) / 2))\n    (fun hε' =>\n      (fun {I} {f} hbound hf hI =>\n          let a := I.a;\n          let b := I.b;\n          fun hsing lower_le_upper M hM hMpos ε hε hε' =>\n          let I' := Icc (a + ε) (b - ε);\n          let Ileft :=\n            match I, hbound, hf, hI, lower_le_upper, hM with\n            | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n            | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n            | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n            | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n          let Iright :=\n            match I, hbound, hf, hI, lower_le_upper, hM with\n            | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n            | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n            | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n            | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n          let Ileft' :=\n            match I, hbound, hf, hI, lower_le_upper, hM with\n            | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n            | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n            | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n            | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n          have Ileftlen :=\n            casesOn (motive := fun t => I = t → Ileft.length = ε) I\n              (fun a b h =>\n                Eq.ndrec (motive := fun {I} =>\n                  ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n                    let a := I.a;\n                    let b := I.b;\n                    a < b →\n                      ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n                        ε < (b - a) / 2 →\n                          let I' := Icc (a + ε) (b - ε);\n                          let Ileft :=\n                            match I, hbound, hf, hI, lower_le_upper, hM with\n                            | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                            | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                            | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                            | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n                          let Iright :=\n                            match I, hbound, hf, hI, lower_le_upper, hM with\n                            | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                            | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                            | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                            | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n                          let Ileft' :=\n                            match I, hbound, hf, hI, lower_le_upper, hM with\n                            | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                            | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                            | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                            | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n                          Ileft.length = ε)\n                  (fun hbound hf hI =>\n                    let a_1 := (Ioo a b).a;\n                    let b_1 := (Ioo a b).b;\n                    fun hsing lower_le_upper hM hε' =>\n                    let I' := Icc (a_1 + ε) (b_1 - ε);\n                    let Ileft :=\n                      match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n                      | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n                      | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n                      | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n                      | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n                    let Iright :=\n                      match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n                      | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n                      | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n                      | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n                      | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n                    let Ileft' :=\n                      match Ioo a b, hbound, hf, hI, lower_le_upper, hM with\n                      | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n                      | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n                      | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n                      | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n                    of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = ε)\n                          (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε))\n                            (sup_of_le_left (le_of_lt hε))))\n                        (eq_self ε)))\n                  (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n              (fun a b h =>\n                Eq.ndrec (motive := fun {I} =>\n                  ∀ (hbound : BddOn f (↑I : Set ℝ)) (hf : ContinuousOn f (↑I : Set ℝ)) (hI : (↑I : Set ℝ).Nonempty),\n                    let a := I.a;\n                    let b := I.b;\n                    a < b →\n                      ∀ (lower_le_upper : lower_integral f I ≤ upper_integral f I) (hM : ∀ x ∈ (↑I : Set ℝ), |f x| ≤ M),\n                        ε < (b - a) / 2 →\n                          let I' := Icc (a + ε) (b - ε);\n                          let Ileft :=\n                            match I, hbound, hf, hI, lower_le_upper, hM with\n                            | Icc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                            | Ico a_1 b, hbound, hf, hI, lower_le_upper, hM => Ico a (a + ε)\n                            | Ioc a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε)\n                            | Ioo a_1 b, hbound, hf, hI, lower_le_upper, hM => Ioo a (a + ε);\n                          let Iright :=\n                            match I, hbound, hf, hI, lower_le_upper, hM with\n                            | Icc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                            | Ico a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b\n                            | Ioc a b_1, hbound, hf, hI, lower_le_upper, hM => Ioc (b - ε) b\n                            | Ioo a b_1, hbound, hf, hI, lower_le_upper, hM => Ioo (b - ε) b;\n                          let Ileft' :=\n                            match I, hbound, hf, hI, lower_le_upper, hM with\n                            | Icc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                            | Ico a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Icc a (b - ε)\n                            | Ioc a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε)\n                            | Ioo a_1 b_1, hbound, hf, hI, lower_le_upper, hM => Ioc a (b - ε);\n                          Ileft.length = ε)\n                  (fun hbound hf hI =>\n                    let a_1 := (Icc a b).a;\n                    let b_1 := (Icc a b).b;\n                    fun hsing lower_le_upper hM hε' =>\n                    let I' := Icc (a_1 + ε) (b_1 - ε);\n                    let Ileft :=\n                      match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n                      | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n                      | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ico a_1 (a_1 + ε)\n                      | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε)\n                      | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo a_1 (a_1 + ε);\n                    let Iright :=\n                      match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n                      | Icc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n                      | Ico a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1\n                      | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc (b_1 - ε) b_1\n                      | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioo (b_1 - ε) b_1;\n                    let Ileft' :=\n                      match Icc a b, hbound, hf, hI, lower_le_upper, hM with\n                      | Icc a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n                      | Ico a b, hbound, hf, hI, lower_le_upper, hM => Icc a_1 (b_1 - ε)\n                      | Ioc a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε)\n                      | Ioo a b, hbound, hf, hI, lower_le_upper, hM => Ioc a_1 (b_1 - ε);\n                    of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = ε)\n                          (Eq.trans (congrArg (fun x => Max.max x 0) (add_sub_cancel_left a_1 ε))\n                            (sup_of_le_left (le_of_lt hε))))\n                        (eq_self ε)))\n                  (Eq.symm h) hbound hf hI hsing lower_le_upper hM hε')\n              (fun a b h => Eq.ndrec (motive := ⋯) ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯) ⋯ ⋯;\n          ⋯)\n        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)\n    ⋯","type":"∀ ε > 0, upper_integral f I - lower_integral f I ≤ (4 * M + 2) * ε","name":["this"],"isProp":true,"id":["_uniq",208788]}]}],"start":9609},{"state":[],"start":9679},{"state":[],"start":9680},{"state":[],"start":9705},{"state":[],"start":9780},{"state":[],"start":9842},{"state":[],"start":9843},{"state":[],"start":9865},{"state":[],"start":9922},{"state":[],"start":9942},{"state":[],"start":9965},{"state":[],"start":9976},{"state":[],"start":9977},{"state":[],"start":10034},{"state":[],"start":10035},{"state":[],"start":10089},{"state":[],"start":10090},{"state":[],"start":10144},{"state":[],"start":10145},{"state":[],"start":10199},{"state":[],"start":10200},{"state":[],"start":10263},{"state":[],"start":10264},{"state":[],"start":10308},{"state":[],"start":10380},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",1017416],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",1017412],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1017413],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",1017414],"binderInfo":"default"},{"type":"PiecewiseContinuousOn f I","name":["hf"],"isProp":true,"id":["_uniq",1017415],"binderInfo":"default"}]}],"start":10459},{"state":[],"start":10467},{"state":[],"start":10468},{"state":[],"start":10491},{"state":[],"start":10583},{"state":[],"start":10669},{"state":[{"type":"∀ x ∈ Icc a b, f x = 0","tag":[],"mvarId":["_uniq",1017875],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1017866],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1017867],"binderInfo":"implicit"},{"type":"a ≤ b","name":["hab"],"isProp":true,"id":["_uniq",1017868],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1017869],"binderInfo":"default"},{"type":"ContinuousOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",1017870],"binderInfo":"default"},{"type":"MajorizesOn f (fun x => 0) (Icc a b)","name":["hnonneg"],"isProp":true,"id":["_uniq",1017871],"binderInfo":"default"},{"type":"integ f (Icc a b) = 0","name":["hinteg"],"isProp":true,"id":["_uniq",1017872],"binderInfo":"default"}]}],"start":10704},{"state":[],"start":10714},{"state":[],"start":10715},{"state":[],"start":10729},{"state":[],"start":10729}]
