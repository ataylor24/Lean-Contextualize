[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":78},{"state":[],"start":79},{"state":[],"start":83},{"state":[],"start":130},{"state":[],"start":131},{"state":[],"start":227},{"state":[],"start":315},{"state":[],"start":410},{"state":[],"start":503},{"state":[],"start":513},{"state":[],"start":514},{"state":[],"start":562},{"state":[],"start":563},{"state":[],"start":624},{"state":[],"start":717},{"state":[],"start":718},{"state":[],"start":920},{"state":[],"start":1019},{"state":[],"start":1107},{"state":[],"start":1204},{"state":[],"start":1306},{"state":[],"start":1403},{"state":[],"start":1505},{"state":[],"start":1602},{"state":[],"start":1677},{"state":[],"start":1769},{"state":[],"start":1772},{"state":[],"start":1773},{"state":[],"start":1792},{"state":[],"start":1793},{"state":[],"start":1891},{"state":[],"start":1990},{"state":[],"start":2013},{"state":[],"start":2014},{"state":[],"start":2115},{"state":[],"start":2210},{"state":[],"start":2226},{"state":[],"start":2340},{"state":[],"start":2341},{"state":[],"start":2383},{"state":[],"start":2442},{"state":[],"start":2485},{"state":[],"start":2528},{"state":[],"start":2608},{"state":[],"start":2633},{"state":[],"start":2659},{"state":[],"start":2663},{"state":[],"start":2664},{"state":[],"start":2686},{"state":[],"start":2750},{"state":[],"start":2765},{"state":[],"start":2781},{"state":[],"start":2801},{"state":[],"start":2822},{"state":[],"start":2824},{"state":[],"start":2825},{"state":[],"start":2904},{"state":[],"start":2928},{"state":[],"start":2954},{"state":[],"start":2979},{"state":[],"start":3000},{"state":[],"start":3002},{"state":[],"start":3003},{"state":[],"start":3079},{"state":[],"start":3096},{"state":[],"start":3151},{"state":[],"start":3210},{"state":[],"start":3231},{"state":[],"start":3233},{"state":[],"start":3234},{"state":[],"start":3319},{"state":[],"start":3343},{"state":[],"start":3372},{"state":[],"start":3387},{"state":[],"start":3402},{"state":[],"start":3427},{"state":[],"start":3448},{"state":[],"start":3450},{"state":[],"start":3451},{"state":[],"start":3545},{"state":[],"start":3574},{"state":[],"start":3603},{"state":[],"start":3618},{"state":[],"start":3635},{"state":[],"start":3652},{"state":[],"start":3677},{"state":[],"start":3698},{"state":[],"start":3700},{"state":[],"start":3701},{"state":[],"start":3727},{"state":[],"start":3807},{"state":[],"start":3862},{"state":[],"start":3863},{"state":[],"start":3967},{"state":[],"start":4012},{"state":[],"start":4013},{"state":[],"start":4032},{"state":[],"start":4113},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",12374],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"}]}],"start":4204},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",12374],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"}]}],"start":4277},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",12745],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]}]}],"start":4376},{"state":[{"type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",13045],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]}]}],"start":4416},{"state":[{"type":"Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",13051],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",13050],"binderInfo":"default"}]}],"start":4428},{"state":[{"type":"Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",13286],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",13050],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",13285]}]}],"start":4474},{"state":[{"type":"Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",17185],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",13050],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",13285]},{"type":"ℝ","name":["s"],"isProp":false,"id":["_uniq",17181],"binderInfo":"default"},{"type":"s ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) < s","name":["hs"],"isProp":true,"id":["_uniq",17184],"binderInfo":"default"}]}],"start":4577},{"state":[{"type":"sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹ ∧ s ≤ sSup E","tag":["property"],"mvarId":["_uniq",37984],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",13050],"binderInfo":"default"},{"type":"ℝ","name":["s"],"isProp":false,"id":["_uniq",17181],"binderInfo":"default"},{"type":"0 < (↑n : ℝ) + 1","name":["this"],"isProp":true,"id":["_uniq",37979],"binderInfo":"default"},{"type":"s ∈ E ∧ sSup E - ((↑n : ℝ) + 1)⁻¹ < s","name":["hs"],"isProp":true,"id":["_uniq",37980],"binderInfo":"default"}]}],"start":4601},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",13047],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]}]}],"start":4687},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",39302],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]}],"start":4736},{"state":[{"type":"Filter.Tendsto (fun n => (↑(a n) : ℝ)) Filter.atTop (nhds (sSup E))","tag":["h","right"],"mvarId":["_uniq",39532],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"∀ (n : ℕ), (↑(a n) : ℝ) ∈ E","tag":["h","left"],"mvarId":["_uniq",39531],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]}],"start":4780},{"state":[{"type":"Filter.Tendsto (fun n => sSup E - 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds (sSup E))","tag":["h","right","hg"],"mvarId":["_uniq",39939],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"Filter.Tendsto (fun x => sSup E) Filter.atTop (nhds (sSup E))","tag":["h","right","hh"],"mvarId":["_uniq",39940],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"(fun n => sSup E - 1 / ((↑n : ℝ) + 1)) ≤ fun n => (↑(a n) : ℝ)","tag":["h","right","hgf"],"mvarId":["_uniq",39941],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"(fun n => (↑(a n) : ℝ)) ≤ fun x => sSup E","tag":["h","right","hfh"],"mvarId":["_uniq",39942],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"∀ (n : ℕ), (↑(a n) : ℝ) ∈ E","tag":["h","left"],"mvarId":["_uniq",39531],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]}],"start":4881},{"state":[{"type":"Filter.Tendsto (fun n => 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds 0)","tag":["h","right","hg","convert_4"],"mvarId":["_uniq",40124],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]}],"start":4947},{"state":[{"type":"Filter.Tendsto (fun x => sSup E) Filter.atTop (nhds (sSup E))","tag":["h","right","hh"],"mvarId":["_uniq",39940],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"(fun n => sSup E - 1 / ((↑n : ℝ) + 1)) ≤ fun n => (↑(a n) : ℝ)","tag":["h","right","hgf"],"mvarId":["_uniq",39941],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"(fun n => (↑(a n) : ℝ)) ≤ fun x => sSup E","tag":["h","right","hfh"],"mvarId":["_uniq",39942],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"∀ (n : ℕ), (↑(a n) : ℝ) ∈ E","tag":["h","left"],"mvarId":["_uniq",39531],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]}],"start":4997},{"state":[{"type":"(fun n => sSup E - 1 / ((↑n : ℝ) + 1)) ≤ fun n => (↑(a n) : ℝ)","tag":["h","right","hgf"],"mvarId":["_uniq",39941],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"(fun n => (↑(a n) : ℝ)) ≤ fun x => sSup E","tag":["h","right","hfh"],"mvarId":["_uniq",39942],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]},{"type":"∀ (n : ℕ), (↑(a n) : ℝ) ∈ E","tag":["h","left"],"mvarId":["_uniq",39531],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",12371],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",12372],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",12373],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",12743]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",13046]},{"type":"(i : ℕ) → (↑(X i) : Type)","name":["a"],"isProp":false,"id":["_uniq",39298],"binderInfo":"default"}]}],"start":5026},{"state":[],"start":5084},{"state":[],"start":5085},{"state":[],"start":5167},{"state":[],"start":5280},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",139225],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"}]}],"start":5371},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",139596],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]}]}],"start":5470},{"state":[{"type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",139908],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]}]}],"start":5510},{"state":[{"type":"Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",139914],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139913],"binderInfo":"default"}]}],"start":5522},{"state":[{"type":"Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",140149],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139913],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",140148]}]}],"start":5568},{"state":[{"type":"Nonempty (↑(X n) : Type)","tag":[],"mvarId":["_uniq",144448],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139913],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",140148]},{"type":"ℝ","name":["s"],"isProp":false,"id":["_uniq",144444],"binderInfo":"default"},{"type":"s ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) < s","name":["hs"],"isProp":true,"id":["_uniq",144447],"binderInfo":"default"}]}],"start":5671},{"state":[{"type":"sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹ ∧ s ≤ sSup E","tag":["property"],"mvarId":["_uniq",166993],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139913],"binderInfo":"default"},{"type":"ℝ","name":["s"],"isProp":false,"id":["_uniq",144444],"binderInfo":"default"},{"type":"0 < (↑n : ℝ) + 1","name":["this"],"isProp":true,"id":["_uniq",166988],"binderInfo":"default"},{"type":"s ∈ E ∧ sSup E - ((↑n : ℝ) + 1)⁻¹ < s","name":["hs"],"isProp":true,"id":["_uniq",166989],"binderInfo":"default"}]}],"start":5695},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",139910],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]}]}],"start":5781},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",168331],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]}]}],"start":5827},{"state":[{"type":"a n ∈ X n","tag":[],"mvarId":["_uniq",168503],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",168422],"binderInfo":"default"}]}],"start":5865},{"state":[{"type":"BddBelow (X n)","tag":[],"mvarId":["_uniq",168816],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",168422],"binderInfo":"default"}]},{"type":"IsClosed (X n)","tag":[],"mvarId":["_uniq",168517],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",168422],"binderInfo":"default"}]}],"start":5920},{"state":[{"type":"IsClosed (X n)","tag":[],"mvarId":["_uniq",168517],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",168422],"binderInfo":"default"}]}],"start":5979},{"state":[{"type":"IsClosed (E ∩ Set.Icc (sSup E - 1 / ((↑n : ℝ) + 1)) (sSup E))","tag":[],"mvarId":["_uniq",202706],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",168422],"binderInfo":"default"}]}],"start":6060},{"state":[{"type":"∃ a, (∀ (n : ℕ), a n ∈ E) ∧ Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":[],"mvarId":["_uniq",168507],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]}],"start":6099},{"state":[{"type":"Filter.Tendsto a Filter.atTop (nhds (sSup E))","tag":["h","right"],"mvarId":["_uniq",268685],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"∀ (n : ℕ), a n ∈ E","tag":["h","left"],"mvarId":["_uniq",268684],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]}],"start":6126},{"state":[{"type":"Filter.Tendsto (fun n => sSup E - 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds (sSup E))","tag":["h","right","hg"],"mvarId":["_uniq",269064],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"Filter.Tendsto (fun x => sSup E) Filter.atTop (nhds (sSup E))","tag":["h","right","hh"],"mvarId":["_uniq",269065],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"(fun n => sSup E - 1 / ((↑n : ℝ) + 1)) ≤ a","tag":["h","right","hgf"],"mvarId":["_uniq",269066],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"a ≤ fun x => sSup E","tag":["h","right","hfh"],"mvarId":["_uniq",269067],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"∀ (n : ℕ), a n ∈ E","tag":["h","left"],"mvarId":["_uniq",268684],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]}],"start":6227},{"state":[{"type":"Filter.Tendsto (fun n => 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds 0)","tag":["h","right","hg","convert_4"],"mvarId":["_uniq",269248],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]}],"start":6293},{"state":[{"type":"Filter.Tendsto (fun x => sSup E) Filter.atTop (nhds (sSup E))","tag":["h","right","hh"],"mvarId":["_uniq",269065],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"(fun n => sSup E - 1 / ((↑n : ℝ) + 1)) ≤ a","tag":["h","right","hgf"],"mvarId":["_uniq",269066],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"a ≤ fun x => sSup E","tag":["h","right","hfh"],"mvarId":["_uniq",269067],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"∀ (n : ℕ), a n ∈ E","tag":["h","left"],"mvarId":["_uniq",268684],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]}],"start":6343},{"state":[{"type":"(fun n => sSup E - 1 / ((↑n : ℝ) + 1)) ≤ a","tag":["h","right","hgf"],"mvarId":["_uniq",269066],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"a ≤ fun x => sSup E","tag":["h","right","hfh"],"mvarId":["_uniq",269067],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]},{"type":"∀ (n : ℕ), a n ∈ E","tag":["h","left"],"mvarId":["_uniq",268684],"isProp":true,"context":[{"type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",139221],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",139222],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",139223],"binderInfo":"default"},{"type":"IsClosed E","name":["hclosed"],"isProp":true,"id":["_uniq",139224],"binderInfo":"default"},{"value":"fun n => {x | x ∈ E ∧ sSup E - 1 / ((↑n : ℝ) + 1) ≤ x ∧ x ≤ sSup E}","type":"ℕ → Set ℝ","name":["X"],"isProp":false,"id":["_uniq",139594]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  (fun s hs =>\n      Nonempty.intro\n        ⟨s,\n          Eq.mpr\n            (id\n              (Eq.trans\n                (Eq.trans\n                  (congrArg (fun x => s ∈ x n)\n                    (funext fun n =>\n                      Eq.trans\n                        (congrArg setOf\n                          (funext fun x =>\n                            congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                              (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                tsub_le_iff_right._simp_1)))\n                        Set.sep_and))\n                  (Set.mem_inter_iff._simp_1 s {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹} {x | x ∈ E ∧ x ≤ sSup E}))\n                (congr\n                  (congrArg And\n                    (Eq.trans\n                      (congrArg (fun x => x ∧ sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹)\n                        (eq_true\n                          (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                      (true_and (sSup E ≤ s + ((↑n : ℝ) + 1)⁻¹))))\n                  (Eq.trans\n                    (congrArg (fun x => x ∧ s ≤ sSup E)\n                      (eq_true (id (Eq.mp (congrArg (fun x => s ∈ E ∧ sSup E - x < s) (one_div ((↑n : ℝ) + 1))) hs)).1))\n                    (true_and (s ≤ sSup E))))))\n            ⟨le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.mul_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                (Mathlib.Tactic.Ring.inv_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.atom_pf'\n                                    (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹)))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right\n                                      (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                            Nat.rawCast 1 *\n                                          Nat.rawCast 1 +\n                                        0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^\n                                          Nat.rawCast 1 *\n                                        Nat.rawCast 1 +\n                                      0))))\n                              (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯),\n              ⋯⟩⟩)\n    ⋯ ⋯","type":"∀ (n : ℕ), Nonempty (↑(X n) : Type)","name":["hX"],"isProp":true,"id":["_uniq",139909]},{"value":"fun n => sInf (X n)","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",168330]},{"value":"fun n =>\n  IsClosed.csInf_mem\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => IsClosed _a)\n          (have this :=\n            Set.ext fun x =>\n              Eq.mpr\n                (id\n                  (congr\n                    (congrArg Iff\n                      (Eq.trans\n                        (congrArg (fun x_1 => x ∈ x_1 n)\n                          (funext fun n =>\n                            Eq.trans\n                              (congrArg setOf\n                                (funext fun x =>\n                                  congrArg (fun x_1 => x ∈ E ∧ x_1 ∧ x ≤ sSup E)\n                                    (Eq.trans (congrArg (fun x_1 => sSup E - x_1 ≤ x) (one_div ((↑n : ℝ) + 1)))\n                                      tsub_le_iff_right._simp_1)))\n                              Set.sep_and))\n                        (Set.mem_inter_iff._simp_1 x {x | x ∈ E ∧ sSup E ≤ x + ((↑n : ℝ) + 1)⁻¹}\n                          {x | x ∈ E ∧ x ≤ sSup E})))\n                    (Eq.trans\n                      (Eq.trans (congrArg (fun x_1 => x ∈ E ∩ Set.Icc (sSup E - x_1) (sSup E)) (one_div ((↑n : ℝ) + 1)))\n                        (Set.mem_inter_iff._simp_1 x E (Set.Icc (sSup E - ((↑n : ℝ) + 1)⁻¹) (sSup E))))\n                      (congrArg (And (x ∈ E))\n                        (Eq.trans Set.mem_Icc._simp_1\n                          (congrArg (fun x_1 => x_1 ∧ x ≤ sSup E) tsub_le_iff_right._simp_1))))))\n                {\n                  mp := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr (congrArg And (eq_true a_1.1.1))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1.2)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)),\n                  mpr := fun a_1 =>\n                    of_eq_true\n                      (Eq.trans\n                        (congr\n                          (congrArg And\n                            (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.1)) (and_self True)))\n                          (Eq.trans (congr (congrArg And (eq_true a_1.1)) (eq_true a_1.2.2)) (and_self True)))\n                        (and_self True)) };\n          this)))\n      (IsClosed.inter hclosed isClosed_Icc))\n    Set.Nonempty.of_subtype\n    (Eq.mpr (id (congrArg (fun _a => _a) (propext bddBelow_def)))\n      (Exists.intro (sSup E - 1 / ((↑n : ℝ) + 1)) fun y a_1 =>\n        of_eq_true\n          (Eq.trans (Eq.trans (congrArg (fun x => sSup E - x ≤ y) (one_div ((↑n : ℝ) + 1))) tsub_le_iff_right._simp_1)\n            (eq_true\n              (id\n                    (Eq.mp\n                      (Eq.trans\n                        (congrArg (fun x => y ∈ x n)\n                          (funext fun n => Eq.trans (congrArg setOf (funext fun x => congrArg ⋯ ⋯)) ⋯))\n                        ⋯)\n                      ⋯)).1.2))))","type":"∀ (n : ℕ), a n ∈ X n","name":["ha"],"isProp":true,"id":["_uniq",168505]}]}],"start":6372},{"state":[],"start":6406},{"state":[],"start":6407},{"state":[],"start":6449},{"state":[],"start":6536},{"state":[{"type":"∃ f, ∀ (x : X), P x (f x)","tag":[],"mvarId":["_uniq",373338],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",373334],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",373335],"binderInfo":"implicit"},{"type":"X → Y → Prop","name":["P"],"isProp":false,"id":["_uniq",373336],"binderInfo":"implicit"},{"type":"∀ (x : X), ∃ y, P x y","name":["h"],"isProp":true,"id":["_uniq",373337],"binderInfo":"default"}]}],"start":6578},{"state":[],"start":6586},{"state":[],"start":6587},{"state":[],"start":6677},{"state":[],"start":6755},{"state":[],"start":6782},{"state":[],"start":6883},{"state":[],"start":6939},{"state":[],"start":6940},{"state":[],"start":6962},{"state":[],"start":7063},{"state":[],"start":7099},{"state":[{"type":"∃ Y, ∀ (α : I), Nat.card (↑(Y ∩ X α) : Type) = 1","tag":[],"mvarId":["_uniq",374230],"isProp":true,"context":[{"type":"Type","name":["I"],"isProp":false,"id":["_uniq",374224],"binderInfo":"implicit"},{"type":"Type","name":["U"],"isProp":false,"id":["_uniq",374225],"binderInfo":"implicit"},{"type":"I → Set U","name":["X"],"isProp":false,"id":["_uniq",374226],"binderInfo":"implicit"},{"type":"Set.univ.PairwiseDisjoint X","name":["h"],"isProp":true,"id":["_uniq",374227],"binderInfo":"default"},{"type":"∀ (α : I), Nonempty (↑(X α) : Type)","name":["hnon"],"isProp":true,"id":["_uniq",374228],"binderInfo":"default"}]}],"start":7164},{"state":[],"start":7172},{"state":[],"start":7173},{"state":[],"start":7263},{"state":[],"start":7356},{"state":[],"start":7383},{"state":[],"start":7499},{"state":[{"type":"Nonempty ((i : I) → X i)","tag":[],"mvarId":["_uniq",374256],"isProp":true,"context":[{"type":"Type","name":["I"],"isProp":false,"id":["_uniq",374253],"binderInfo":"implicit"},{"type":"I → Type","name":["X"],"isProp":false,"id":["_uniq",374254],"binderInfo":"implicit"},{"type":"∀ (i : I), Nonempty (X i)","name":["h"],"isProp":true,"id":["_uniq",374255],"binderInfo":"default"}]}],"start":7529},{"state":[],"start":7537},{"state":[],"start":7538},{"state":[],"start":7560},{"state":[],"start":7656},{"state":[{"type":"∃ f, Function.Injective f ∧ Function.RightInverse f g","tag":[],"mvarId":["_uniq",374307],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",374303],"binderInfo":"implicit"},{"type":"Type","name":["B"],"isProp":false,"id":["_uniq",374304],"binderInfo":"implicit"},{"type":"B → A","name":["g"],"isProp":false,"id":["_uniq",374305],"binderInfo":"implicit"},{"type":"Function.Surjective g","name":["hg"],"isProp":true,"id":["_uniq",374306],"binderInfo":"default"}]}],"start":7732},{"state":[],"start":7740},{"state":[],"start":7741},{"state":[],"start":7831},{"state":[],"start":7927},{"state":[],"start":7954},{"state":[],"start":8073},{"state":[{"type":"Nonempty ((i : I) → X i)","tag":[],"mvarId":["_uniq",374333],"isProp":true,"context":[{"type":"Type","name":["I"],"isProp":false,"id":["_uniq",374330],"binderInfo":"implicit"},{"type":"I → Type","name":["X"],"isProp":false,"id":["_uniq",374331],"binderInfo":"implicit"},{"type":"∀ (i : I), Nonempty (X i)","name":["h"],"isProp":true,"id":["_uniq",374332],"binderInfo":"default"}]}],"start":8103},{"state":[],"start":8111},{"state":[],"start":8112},{"state":[],"start":8125},{"state":[],"start":8125}]
