[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":51},{"state":[],"start":52},{"state":[],"start":56},{"state":[],"start":111},{"state":[],"start":112},{"state":[],"start":208},{"state":[],"start":297},{"state":[],"start":393},{"state":[],"start":486},{"state":[],"start":496},{"state":[],"start":497},{"state":[],"start":545},{"state":[],"start":546},{"state":[],"start":602},{"state":[],"start":615},{"state":[],"start":654},{"state":[],"start":655},{"state":[],"start":679},{"state":[],"start":680},{"state":[],"start":824},{"state":[],"start":825},{"state":[],"start":842},{"state":[],"start":843},{"state":[],"start":846},{"state":[],"start":847},{"state":[],"start":866},{"state":[],"start":867},{"state":[],"start":949},{"state":[],"start":997},{"state":[],"start":998},{"state":[],"start":1047},{"state":[],"start":1048},{"state":[],"start":1119},{"state":[],"start":1120},{"state":[],"start":1226},{"state":[],"start":1227},{"state":[],"start":1321},{"state":[],"start":1397},{"state":[],"start":1452},{"state":[],"start":1453},{"state":[],"start":1494},{"state":[],"start":1568},{"state":[],"start":1569},{"state":[],"start":1610},{"state":[],"start":1682},{"state":[],"start":1683},{"state":[],"start":1724},{"state":[],"start":1798},{"state":[],"start":1799},{"state":[],"start":1840},{"state":[],"start":1927},{"state":[],"start":1928},{"state":[],"start":1969},{"state":[],"start":2048},{"state":[],"start":2049},{"state":[],"start":2090},{"state":[],"start":2162},{"state":[],"start":2163},{"state":[],"start":2204},{"state":[],"start":2302},{"state":[],"start":2303},{"state":[],"start":2344},{"state":[],"start":2450},{"state":[],"start":2451},{"state":[],"start":2492},{"state":[],"start":2558},{"state":[],"start":2559},{"state":[],"start":2685},{"state":[],"start":2756},{"state":[],"start":2757},{"state":[],"start":2765},{"state":[],"start":2824},{"state":[],"start":2825},{"state":[],"start":2898},{"state":[],"start":2899},{"state":[],"start":2940},{"state":[],"start":3028},{"state":[],"start":3029},{"state":[],"start":3070},{"state":[],"start":3143},{"state":[],"start":3144},{"state":[],"start":3185},{"state":[],"start":3260},{"state":[],"start":3261},{"state":[],"start":3302},{"state":[],"start":3375},{"state":[],"start":3376},{"state":[],"start":3417},{"state":[],"start":3526},{"state":[],"start":3527},{"state":[{"type":"x ^ n ≤ y ^ n","tag":[],"mvarId":["_uniq",6722],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",6716],"binderInfo":"implicit"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",6717],"binderInfo":"implicit"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",6718],"binderInfo":"implicit"},{"type":"x ≥ y","name":["hxy"],"isProp":true,"id":["_uniq",6719],"binderInfo":"default"},{"type":"y > 0","name":["hy"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"type":"n < 0","name":["hn"],"isProp":true,"id":["_uniq",6721],"binderInfo":"default"}]}],"start":3637},{"state":[],"start":3645},{"state":[],"start":3646},{"state":[],"start":3687},{"state":[{"type":"x = y","tag":[],"mvarId":["_uniq",6920],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",6913],"binderInfo":"implicit"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",6914],"binderInfo":"implicit"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",6915],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",6916],"binderInfo":"default"},{"type":"y > 0","name":["hy"],"isProp":true,"id":["_uniq",6917],"binderInfo":"default"},{"type":"n ≠ 0","name":["hn"],"isProp":true,"id":["_uniq",6918],"binderInfo":"default"},{"type":"x ^ n = y ^ n","name":["hxy"],"isProp":true,"id":["_uniq",6919],"binderInfo":"default"}]}],"start":3798},{"state":[],"start":3806},{"state":[],"start":3847},{"state":[],"start":3914},{"state":[],"start":3915},{"state":[],"start":4005},{"state":[],"start":4103},{"state":[],"start":4104},{"state":[],"start":4156},{"state":[],"start":4157},{"state":[],"start":4202},{"state":[{"type":"{y | y ≥ 0 ∧ y ^ n ≤ x}.Nonempty","tag":[],"mvarId":["_uniq",7530],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7526],"binderInfo":"implicit"},{"type":"x ≥ 0","name":["hx"],"isProp":true,"id":["_uniq",7527],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7528],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7529],"binderInfo":"default"}]}],"start":4329},{"state":[{"type":"0 ∈ {y | y ≥ 0 ∧ y ^ n ≤ x}","tag":["h"],"mvarId":["_uniq",7535],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7526],"binderInfo":"implicit"},{"type":"x ≥ 0","name":["hx"],"isProp":true,"id":["_uniq",7527],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7528],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7529],"binderInfo":"default"}]}],"start":4337},{"state":[],"start":4345},{"state":[],"start":4346},{"state":[{"type":"BddAbove {y | y ≥ 0 ∧ y ^ n ≤ x}","tag":[],"mvarId":["_uniq",7867],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"}]}],"start":4459},{"state":[{"type":"BddAbove {y | y ≥ 0 ∧ y ^ n ≤ x}","tag":[],"mvarId":["_uniq",7867],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"}]}],"start":4532},{"state":[{"type":"∃ x_1, ∀ y ∈ {y | y ≥ 0 ∧ y ^ n ≤ x}, y ≤ x_1","tag":[],"mvarId":["_uniq",8091],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"}]}],"start":4559},{"state":[{"type":"∃ x_1, ∀ y ∈ {y | y ≥ 0 ∧ y ^ n ≤ x}, y ≤ x_1","tag":["inl"],"mvarId":["_uniq",8236],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"x ≤ 1","name":["h"],"isProp":true,"id":["_uniq",8235],"binderInfo":"default"}]},{"type":"∃ x_1, ∀ y ∈ {y | y ≥ 0 ∧ y ^ n ≤ x}, y ≤ x_1","tag":["inr"],"mvarId":["_uniq",8241],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"1 < x","name":["h"],"isProp":true,"id":["_uniq",8240],"binderInfo":"default"}]}],"start":4590},{"state":[{"type":"y ≤ 1","tag":["h"],"mvarId":["_uniq",13025],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"x ≤ 1","name":["h"],"isProp":true,"id":["_uniq",8235],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",8302],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",13022],"binderInfo":"default"}]}],"start":4624},{"state":[{"type":"False","tag":["h"],"mvarId":["_uniq",13515],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"x ≤ 1","name":["h"],"isProp":true,"id":["_uniq",8235],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",8302],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",13022],"binderInfo":"default"},{"type":"1 < y","name":["hy'"],"isProp":true,"id":["_uniq",13514],"binderInfo":"default"}]}],"start":4643},{"state":[{"type":"1 < y ^ n","tag":[],"mvarId":["_uniq",13663],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"x ≤ 1","name":["h"],"isProp":true,"id":["_uniq",8235],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",8302],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",13022],"binderInfo":"default"},{"type":"1 < y","name":["hy'"],"isProp":true,"id":["_uniq",13514],"binderInfo":"default"}]}],"start":4675},{"state":[{"type":"False","tag":["h"],"mvarId":["_uniq",13669],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"x ≤ 1","name":["h"],"isProp":true,"id":["_uniq",8235],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",8302],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",13022],"binderInfo":"default"},{"value":"sorry","type":"1 < y ^ n","name":["hy'"],"isProp":true,"id":["_uniq",13664]}]}],"start":4687},{"state":[{"type":"∃ x_1, ∀ y ∈ {y | y ≥ 0 ∧ y ^ n ≤ x}, y ≤ x_1","tag":["inr"],"mvarId":["_uniq",8241],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"1 < x","name":["h"],"isProp":true,"id":["_uniq",8240],"binderInfo":"default"}]}],"start":4700},{"state":[{"type":"y ≤ x","tag":["h"],"mvarId":["_uniq",20349],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"1 < x","name":["h"],"isProp":true,"id":["_uniq",8240],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",15756],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",20346],"binderInfo":"default"}]}],"start":4732},{"state":[{"type":"False","tag":["h"],"mvarId":["_uniq",20844],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"1 < x","name":["h"],"isProp":true,"id":["_uniq",8240],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",15756],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",20346],"binderInfo":"default"},{"type":"x < y","name":["hy'"],"isProp":true,"id":["_uniq",20843],"binderInfo":"default"}]}],"start":4749},{"state":[{"type":"x < y ^ n","tag":[],"mvarId":["_uniq",20959],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"1 < x","name":["h"],"isProp":true,"id":["_uniq",8240],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",15756],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",20346],"binderInfo":"default"},{"type":"x < y","name":["hy'"],"isProp":true,"id":["_uniq",20843],"binderInfo":"default"}]}],"start":4779},{"state":[{"type":"False","tag":["h"],"mvarId":["_uniq",20965],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",7864],"binderInfo":"implicit"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",7865],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",7866],"binderInfo":"default"},{"type":"1 < x","name":["h"],"isProp":true,"id":["_uniq",8240],"binderInfo":"default"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",15756],"binderInfo":"default"},{"type":"0 ≤ y ∧ y ^ n ≤ x","name":["hy"],"isProp":true,"id":["_uniq",20346],"binderInfo":"default"},{"value":"sorry","type":"x < y ^ n","name":["hy'"],"isProp":true,"id":["_uniq",20960]}]}],"start":4789},{"state":[],"start":4800},{"state":[],"start":4801},{"state":[],"start":4842},{"state":[],"start":4937},{"state":[],"start":4976},{"state":[],"start":4977},{"state":[],"start":5017},{"state":[],"start":5116},{"state":[],"start":5117},{"state":[],"start":5157},{"state":[],"start":5261},{"state":[],"start":5262},{"state":[],"start":5334},{"state":[],"start":5365},{"state":[],"start":5366},{"state":[],"start":5438},{"state":[],"start":5469},{"state":[],"start":5470},{"state":[],"start":5510},{"state":[],"start":5638},{"state":[],"start":5639},{"state":[],"start":5679},{"state":[],"start":5807},{"state":[],"start":5808},{"state":[],"start":5848},{"state":[],"start":5989},{"state":[],"start":5990},{"state":[],"start":6030},{"state":[],"start":6111},{"state":[],"start":6112},{"state":[],"start":6152},{"state":[],"start":6288},{"state":[],"start":6289},{"state":[],"start":6329},{"state":[],"start":6459},{"state":[],"start":6460},{"state":[],"start":6529},{"state":[],"start":6530},{"state":[],"start":6611},{"state":[],"start":6648},{"state":[],"start":6649},{"state":[{"type":"¬∀ (y z : Real), ∀ n ≥ 1, y ^ n = z ^ n → y = z","tag":[],"mvarId":["_uniq",25421],"isProp":true,"context":[]}],"start":6734},{"state":[],"start":6793},{"state":[],"start":6794},{"state":[],"start":6818},{"state":[],"start":6901},{"state":[],"start":6902},{"state":[],"start":6962},{"state":[],"start":6986},{"state":[],"start":6987},{"state":[{"type":"∃ a, ∃ b > 0, q = (↑a : ℚ) / (↑b : ℚ)","tag":[],"mvarId":["_uniq",64954],"isProp":true,"context":[{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",64953],"binderInfo":"default"}]}],"start":7065},{"state":[{"type":"q.den > 0 ∧ q = (↑q.num : ℚ) / (↑q.den : ℚ)","tag":["h"],"mvarId":["_uniq",65028],"isProp":true,"context":[{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",64953],"binderInfo":"default"},{"value":"q.den_nz","type":"q.den ≠ 0","name":["this"],"isProp":true,"id":["_uniq",65027]}]}],"start":7102},{"state":[],"start":7154},{"state":[],"start":7155},{"state":[],"start":7174},{"state":[],"start":7257},{"state":[],"start":7313},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":[],"mvarId":["_uniq",65692],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"}]}],"start":7357},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":[],"mvarId":["_uniq",65692],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"}]}],"start":7430},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr"],"mvarId":["_uniq",65782],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"¬a > 0","name":["ha"],"isProp":true,"id":["_uniq",65781],"binderInfo":"default"}]},{"type":"x.root b' ^ a' = x.root b ^ a","tag":[],"mvarId":["_uniq",65755],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65745],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65746],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65751],"binderInfo":"default"},{"type":"a > 0","name":["ha"],"isProp":true,"id":["_uniq",65754],"binderInfo":"default"}]}],"start":7470},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr"],"mvarId":["_uniq",67262],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"}]}],"start":7485},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr","inl"],"mvarId":["_uniq",67507],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a < 0","name":["ha"],"isProp":true,"id":["_uniq",67506],"binderInfo":"default"}]},{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr","inr"],"mvarId":["_uniq",67512],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a = 0","name":["ha"],"isProp":true,"id":["_uniq",67511],"binderInfo":"default"}]}],"start":7529},{"state":[{"type":"(↑(-a) : ℚ) / (↑b : ℚ) = (↑(-a') : ℚ) / (↑b' : ℚ)","tag":[],"mvarId":["_uniq",67824],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a < 0","name":["ha"],"isProp":true,"id":["_uniq",67506],"binderInfo":"default"}]}],"start":7592},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr","inl"],"mvarId":["_uniq",80752],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a < 0","name":["ha"],"isProp":true,"id":["_uniq",67506],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congr (congrArg (fun x => Eq (x / (↑b : ℚ))) (Int.cast_neg a))\n      (congrArg (fun x => x / (↑b' : ℚ)) (Int.cast_neg a'))))\n  (Eq.mpr\n    (id\n      (congr\n        (congrArg Eq\n          (Eq.trans\n            (Mathlib.Tactic.Ring.div_congr\n              (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑a : ℚ))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (↑a : ℚ) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.atom_pf (↑b : ℚ))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑b : ℚ)⁻¹)\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1)))))\n                    (Mathlib.Tactic.Ring.mul_pf_right (↑b : ℚ)⁻¹ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left (↑a : ℚ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.mul_pf_right (↑b : ℚ)⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                    (Mathlib.Tactic.Ring.mul_zero ((↑a : ℚ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑a : ℚ) ^ Nat.rawCast 1 * ((↑b : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((↑b : ℚ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((↑a : ℚ) ^ Nat.rawCast 1 * ((↑b : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n            (Eq.trans\n              (congrArg (fun x => x + 0)\n                (Eq.trans\n                  (congr\n                    (congrArg HMul.hMul\n                      (Eq.trans (congrArg (HPow.hPow (↑a : ℚ)) Mathlib.Tactic.RingNF.nat_rawCast_1) (pow_one (↑a : ℚ))))\n                    (Eq.trans\n                      (Eq.trans\n                        (congr\n                          (congrArg HMul.hMul\n                            (Eq.trans (congrArg (HPow.hPow (↑b : ℚ)⁻¹) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                              (pow_one (↑b : ℚ)⁻¹)))\n                          (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                            (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                        (Mathlib.Tactic.RingNF.mul_neg (↑b : ℚ)⁻¹ 1))\n                      (congrArg Neg.neg (mul_one (↑b : ℚ)⁻¹))))\n                  (Mathlib.Tactic.RingNF.mul_neg (↑a : ℚ) (↑b : ℚ)⁻¹)))\n              (add_zero (-((↑a : ℚ) * (↑b : ℚ)⁻¹))))))\n        (Eq.trans\n          (Mathlib.Tactic.Ring.div_congr\n            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑a' : ℚ))\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul (↑a' : ℚ) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero))\n            (Mathlib.Tactic.Ring.atom_pf (↑b' : ℚ))\n            (Mathlib.Tactic.Ring.div_pf\n              (Mathlib.Tactic.Ring.inv_single\n                (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑b' : ℚ)⁻¹)\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1)))))\n                  (Mathlib.Tactic.Ring.mul_pf_right (↑b' : ℚ)⁻¹ (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (↑a' : ℚ) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (↑b' : ℚ)⁻¹ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero ((↑a' : ℚ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((↑a' : ℚ) ^ Nat.rawCast 1 * ((↑b' : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.zero_mul ((↑b' : ℚ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  ((↑a' : ℚ) ^ Nat.rawCast 1 * ((↑b' : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n          (Eq.trans\n            (congrArg (fun x => x + 0)\n              (Eq.trans\n                (congr\n                  (congrArg HMul.hMul\n                    (Eq.trans (congrArg (HPow.hPow (↑a' : ℚ)) Mathlib.Tactic.RingNF.nat_rawCast_1) (pow_one (↑a' : ℚ))))\n                  (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯))\n                ⋯))\n            ⋯))))\n    ⋯)","type":"(↑(-a) : ℚ) / (↑b : ℚ) = (↑(-a') : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",67825]}]}],"start":7640},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr","inl"],"mvarId":["_uniq",83402],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a < 0","name":["ha"],"isProp":true,"id":["_uniq",67506],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congr (congrArg (fun x => Eq (x / (↑b : ℚ))) (Int.cast_neg a))\n      (congrArg (fun x => x / (↑b' : ℚ)) (Int.cast_neg a'))))\n  (Eq.mpr\n    (id\n      (congr\n        (congrArg Eq\n          (Eq.trans\n            (Mathlib.Tactic.Ring.div_congr\n              (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑a : ℚ))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (↑a : ℚ) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.atom_pf (↑b : ℚ))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑b : ℚ)⁻¹)\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1)))))\n                    (Mathlib.Tactic.Ring.mul_pf_right (↑b : ℚ)⁻¹ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left (↑a : ℚ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.mul_pf_right (↑b : ℚ)⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                    (Mathlib.Tactic.Ring.mul_zero ((↑a : ℚ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑a : ℚ) ^ Nat.rawCast 1 * ((↑b : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((↑b : ℚ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((↑a : ℚ) ^ Nat.rawCast 1 * ((↑b : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n            (Eq.trans\n              (congrArg (fun x => x + 0)\n                (Eq.trans\n                  (congr\n                    (congrArg HMul.hMul\n                      (Eq.trans (congrArg (HPow.hPow (↑a : ℚ)) Mathlib.Tactic.RingNF.nat_rawCast_1) (pow_one (↑a : ℚ))))\n                    (Eq.trans\n                      (Eq.trans\n                        (congr\n                          (congrArg HMul.hMul\n                            (Eq.trans (congrArg (HPow.hPow (↑b : ℚ)⁻¹) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                              (pow_one (↑b : ℚ)⁻¹)))\n                          (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                            (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                        (Mathlib.Tactic.RingNF.mul_neg (↑b : ℚ)⁻¹ 1))\n                      (congrArg Neg.neg (mul_one (↑b : ℚ)⁻¹))))\n                  (Mathlib.Tactic.RingNF.mul_neg (↑a : ℚ) (↑b : ℚ)⁻¹)))\n              (add_zero (-((↑a : ℚ) * (↑b : ℚ)⁻¹))))))\n        (Eq.trans\n          (Mathlib.Tactic.Ring.div_congr\n            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑a' : ℚ))\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul (↑a' : ℚ) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero))\n            (Mathlib.Tactic.Ring.atom_pf (↑b' : ℚ))\n            (Mathlib.Tactic.Ring.div_pf\n              (Mathlib.Tactic.Ring.inv_single\n                (Mathlib.Tactic.Ring.inv_mul (Eq.refl (↑b' : ℚ)⁻¹)\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1)))))\n                  (Mathlib.Tactic.Ring.mul_pf_right (↑b' : ℚ)⁻¹ (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (↑a' : ℚ) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (↑b' : ℚ)⁻¹ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero ((↑a' : ℚ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((↑a' : ℚ) ^ Nat.rawCast 1 * ((↑b' : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.zero_mul ((↑b' : ℚ)⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  ((↑a' : ℚ) ^ Nat.rawCast 1 * ((↑b' : ℚ)⁻¹ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n          (Eq.trans\n            (congrArg (fun x => x + 0)\n              (Eq.trans\n                (congr\n                  (congrArg HMul.hMul\n                    (Eq.trans (congrArg (HPow.hPow (↑a' : ℚ)) Mathlib.Tactic.RingNF.nat_rawCast_1) (pow_one (↑a' : ℚ))))\n                  (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯))\n                ⋯))\n            ⋯))))\n    ⋯)","type":"(↑(-a) : ℚ) / (↑b : ℚ) = (↑(-a') : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",67825]},{"type":"x.root b' ^ (-a') = x.root b ^ (-a)","name":["this"],"isProp":true,"id":["_uniq",83399],"binderInfo":"default"}]}],"start":7686},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr","inr"],"mvarId":["_uniq",67512],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a = 0","name":["ha"],"isProp":true,"id":["_uniq",67511],"binderInfo":"default"}]}],"start":7720},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["inr","inr"],"mvarId":["_uniq",84596],"isProp":true,"context":[{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65683],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65684],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65685],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65686],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65687],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65688],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65689],"binderInfo":"default"},{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"∀ {a a' : ℤ} {b b' : ℕ},\n  b > 0 → b' > 0 → (↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ) → a > 0 → x.root b' ^ a' = x.root b ^ a","name":["this✝"],"isProp":true,"id":["_uniq",65735],"binderInfo":"default"},{"type":"a ≤ 0","name":["ha✝"],"isProp":true,"id":["_uniq",67259],"binderInfo":"default"},{"type":"a = 0","name":["ha"],"isProp":true,"id":["_uniq",67511],"binderInfo":"default"},{"value":"sorry","type":"a' = 0","name":["this"],"isProp":true,"id":["_uniq",84595]}]}],"start":7750},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":[],"mvarId":["_uniq",65755],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65745],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65746],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65751],"binderInfo":"default"},{"type":"a > 0","name":["ha"],"isProp":true,"id":["_uniq",65754],"binderInfo":"default"}]}],"start":7763},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":[],"mvarId":["_uniq",132181],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65745],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65746],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑a' : ℚ) / (↑b' : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",65751],"binderInfo":"default"},{"type":"a > 0","name":["ha"],"isProp":true,"id":["_uniq",65754],"binderInfo":"default"},{"value":"sorry","type":"a' > 0","name":["this"],"isProp":true,"id":["_uniq",132180]}]}],"start":7791},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":[],"mvarId":["_uniq",136935],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",65745],"binderInfo":"implicit"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65746],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"a > 0","name":["ha"],"isProp":true,"id":["_uniq",65754],"binderInfo":"default"},{"value":"sorry","type":"a' > 0","name":["this"],"isProp":true,"id":["_uniq",132180]},{"type":"(↑a : ℚ) * (↑b' : ℚ) = (↑a' : ℚ) * (↑b : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",136932],"binderInfo":"default"}]}],"start":7810},{"state":[{"type":"x.root b' ^ a' = x.root b ^ (↑a : ℤ)","tag":["intro"],"mvarId":["_uniq",140857],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"ℤ","name":["a'"],"isProp":false,"id":["_uniq",65746],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"value":"sorry","type":"a' > 0","name":["this"],"isProp":true,"id":["_uniq",132180]},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"(↑a : ℤ) > 0","name":["ha"],"isProp":true,"id":["_uniq",140855],"binderInfo":"default"},{"type":"(↑(↑a : ℤ) : ℚ) * (↑b' : ℚ) = (↑a' : ℚ) * (↑b : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",140856],"binderInfo":"default"}]}],"start":7841},{"state":[{"type":"x.root b' ^ (↑a' : ℤ) = x.root b ^ (↑a : ℤ)","tag":["intro","intro"],"mvarId":["_uniq",144780],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",65691],"binderInfo":"default"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"(↑a : ℤ) > 0","name":["ha"],"isProp":true,"id":["_uniq",140855],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"(↑a' : ℤ) > 0","name":["this"],"isProp":true,"id":["_uniq",144778],"binderInfo":"default"},{"type":"(↑(↑a : ℤ) : ℚ) * (↑b' : ℚ) = (↑(↑a' : ℤ) : ℚ) * (↑b : ℚ)","name":["hq"],"isProp":true,"id":["_uniq",144779],"binderInfo":"default"}]}],"start":7873},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["intro","intro"],"mvarId":["_uniq",149156],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",145015],"binderInfo":"default"},{"type":"0 < a","name":["ha"],"isProp":true,"id":["_uniq",145377],"binderInfo":"default"},{"type":"0 < a'","name":["this"],"isProp":true,"id":["_uniq",145431],"binderInfo":"default"},{"type":"a * b' = a' * b","name":["hq"],"isProp":true,"id":["_uniq",149155],"binderInfo":"default"}]}],"start":7890},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["intro","intro"],"mvarId":["_uniq",149745],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",145015],"binderInfo":"default"},{"type":"0 < a","name":["ha"],"isProp":true,"id":["_uniq",145377],"binderInfo":"default"},{"type":"0 < a'","name":["this"],"isProp":true,"id":["_uniq",145431],"binderInfo":"default"},{"type":"a * b' = a' * b","name":["hq"],"isProp":true,"id":["_uniq",149155],"binderInfo":"default"},{"value":"x.root (a * b')","type":"Real","name":["y"],"isProp":false,"id":["_uniq",149744]}]}],"start":7915},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["intro","intro"],"mvarId":["_uniq",149893],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",145015],"binderInfo":"default"},{"type":"0 < a","name":["ha"],"isProp":true,"id":["_uniq",145377],"binderInfo":"default"},{"type":"0 < a'","name":["this"],"isProp":true,"id":["_uniq",145431],"binderInfo":"default"},{"type":"a * b' = a' * b","name":["hq"],"isProp":true,"id":["_uniq",149155],"binderInfo":"default"},{"value":"x.root (a * b')","type":"Real","name":["y"],"isProp":false,"id":["_uniq",149744]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b' : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b')\n                            (congrArg (fun x => x < (↑b' : ℤ)) Nat.cast_zero))\n                          hb')))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b' 1)\n                          (congrArg (LT.lt (↑b' : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b').root a","name":["h1"],"isProp":true,"id":["_uniq",149892]}]}],"start":7994},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["intro","intro"],"mvarId":["_uniq",163956],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",145015],"binderInfo":"default"},{"type":"0 < a","name":["ha"],"isProp":true,"id":["_uniq",145377],"binderInfo":"default"},{"type":"0 < a'","name":["this"],"isProp":true,"id":["_uniq",145431],"binderInfo":"default"},{"type":"a * b' = a' * b","name":["hq"],"isProp":true,"id":["_uniq",149155],"binderInfo":"default"},{"value":"x.root (a * b')","type":"Real","name":["y"],"isProp":false,"id":["_uniq",149744]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b' : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b')\n                            (congrArg (fun x => x < (↑b' : ℤ)) Nat.cast_zero))\n                          hb')))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b' 1)\n                          (congrArg (LT.lt (↑b' : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b').root a","name":["h1"],"isProp":true,"id":["_uniq",149892]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b)\n                            (congrArg (fun x => x < (↑b : ℤ)) Nat.cast_zero))\n                          hb)))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b 1) (congrArg (LT.lt (↑b : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b).root a'","name":["h2"],"isProp":true,"id":["_uniq",163955]}]}],"start":8080},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["intro","intro"],"mvarId":["_uniq",178251],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",145015],"binderInfo":"default"},{"type":"0 < a","name":["ha"],"isProp":true,"id":["_uniq",145377],"binderInfo":"default"},{"type":"0 < a'","name":["this"],"isProp":true,"id":["_uniq",145431],"binderInfo":"default"},{"type":"a * b' = a' * b","name":["hq"],"isProp":true,"id":["_uniq",149155],"binderInfo":"default"},{"value":"x.root (a * b')","type":"Real","name":["y"],"isProp":false,"id":["_uniq",149744]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b' : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b')\n                            (congrArg (fun x => x < (↑b' : ℤ)) Nat.cast_zero))\n                          hb')))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b' 1)\n                          (congrArg (LT.lt (↑b' : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b').root a","name":["h1"],"isProp":true,"id":["_uniq",149892]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b)\n                            (congrArg (fun x => x < (↑b : ℤ)) Nat.cast_zero))\n                          hb)))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b 1) (congrArg (LT.lt (↑b : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b).root a'","name":["h2"],"isProp":true,"id":["_uniq",163955]},{"value":"Eq.mpr (id (congrArg (fun _a => _a ^ a = x.root b') h1))\n  (pow_of_root\n    (root_nonneg\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n            (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑b' : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b' : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b')\n                          (congrArg (fun x => x < (↑b' : ℤ)) Nat.cast_zero))\n                        hb')))))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b' 1) (congrArg (LT.lt (↑b' : ℤ)) Nat.cast_one))\n                      a))))))))\n    (le_of_not_gt fun a_1 =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.atom_pf (↑a : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑a : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑a : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯)) ⋯))\n                    ⋯))\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"y ^ a = x.root b'","name":["h3"],"isProp":true,"id":["_uniq",178250]}]}],"start":8172},{"state":[{"type":"x.root b' ^ a' = x.root b ^ a","tag":["intro","intro"],"mvarId":["_uniq",192433],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",65690],"binderInfo":"implicit"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",65747],"binderInfo":"implicit"},{"type":"ℕ","name":["b'"],"isProp":false,"id":["_uniq",65748],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",65749],"binderInfo":"default"},{"type":"b' > 0","name":["hb'"],"isProp":true,"id":["_uniq",65750],"binderInfo":"default"},{"type":"ℕ","name":["a"],"isProp":false,"id":["_uniq",140840],"binderInfo":"default"},{"type":"ℕ","name":["a'"],"isProp":false,"id":["_uniq",144763],"binderInfo":"default"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",145015],"binderInfo":"default"},{"type":"0 < a","name":["ha"],"isProp":true,"id":["_uniq",145377],"binderInfo":"default"},{"type":"0 < a'","name":["this"],"isProp":true,"id":["_uniq",145431],"binderInfo":"default"},{"type":"a * b' = a' * b","name":["hq"],"isProp":true,"id":["_uniq",149155],"binderInfo":"default"},{"value":"x.root (a * b')","type":"Real","name":["y"],"isProp":false,"id":["_uniq",149744]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b' : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b')\n                            (congrArg (fun x => x < (↑b' : ℤ)) Nat.cast_zero))\n                          hb')))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b' 1)\n                          (congrArg (LT.lt (↑b' : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b').root a","name":["h1"],"isProp":true,"id":["_uniq",149892]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => y = _a)\n      (root_root\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n                (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑b : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                    (Int.add_one_le_iff.mpr\n                      (id\n                        (Eq.mp\n                          (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b)\n                            (congrArg (fun x => x < (↑b : ℤ)) Nat.cast_zero))\n                          hb)))))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b 1) (congrArg (LT.lt (↑b : ℤ)) Nat.cast_one))\n                        a)))))))\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.atom_pf (↑a' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑a' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              ((↑a' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add ⋯)))\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯)))))\n  ⋯","type":"y = (x.root b).root a'","name":["h2"],"isProp":true,"id":["_uniq",163955]},{"value":"Eq.mpr (id (congrArg (fun _a => _a ^ a = x.root b') h1))\n  (pow_of_root\n    (root_nonneg\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n            (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑b' : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑b' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b' : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b' : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b')\n                          (congrArg (fun x => x < (↑b' : ℤ)) Nat.cast_zero))\n                        hb')))))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b' 1) (congrArg (LT.lt (↑b' : ℤ)) Nat.cast_one))\n                      a))))))))\n    (le_of_not_gt fun a_1 =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.atom_pf (↑a : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑a : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑a : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯)) ⋯))\n                    ⋯))\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"y ^ a = x.root b'","name":["h3"],"isProp":true,"id":["_uniq",178250]},{"value":"Eq.mpr (id (congrArg (fun _a => _a ^ a' = x.root b) h2))\n  (pow_of_root\n    (root_nonneg\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n            (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hx)\n              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑b : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑b : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑b : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑b : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑b : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (Int.add_one_le_iff.mpr\n                    (id\n                      (Eq.mp\n                        (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 b)\n                          (congrArg (fun x => x < (↑b : ℤ)) Nat.cast_zero))\n                        hb)))))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 b 1) (congrArg (LT.lt (↑b : ℤ)) Nat.cast_one))\n                      a))))))))\n    (le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.atom_pf (↑a' : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑a' : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑a' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯)) ⋯))\n                    ⋯))\n                ⋯ ⋯)\n              ⋯))\n          ⋯)))","type":"y ^ a' = x.root b","name":["h4"],"isProp":true,"id":["_uniq",192432]}]}],"start":8264},{"state":[],"start":8312},{"state":[],"start":8313},{"state":[{"type":"x ^ ((↑a : ℚ) / (↑b : ℚ)) = x.root b ^ a","tag":[],"mvarId":["_uniq",207134],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",207129],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",207130],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",207131],"binderInfo":"default"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",207132],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",207133],"binderInfo":"default"}]}],"start":8421},{"state":[{"type":"x ^ q = x.root b ^ a","tag":[],"mvarId":["_uniq",207316],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",207129],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",207130],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",207131],"binderInfo":"default"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",207132],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",207133],"binderInfo":"default"},{"value":"(↑a : ℚ) / (↑b : ℚ)","type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",207297]}]}],"start":8442},{"state":[{"type":"q.den > 0","tag":["convert_4"],"mvarId":["_uniq",207380],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",207129],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",207130],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",207131],"binderInfo":"default"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",207132],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",207133],"binderInfo":"default"},{"value":"(↑a : ℚ) / (↑b : ℚ)","type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",207297]}]},{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑q.num : ℚ) / (↑q.den : ℚ)","tag":["convert_5"],"mvarId":["_uniq",207381],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",207129],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",207130],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",207131],"binderInfo":"default"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",207132],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",207133],"binderInfo":"default"},{"value":"(↑a : ℚ) / (↑b : ℚ)","type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",207297]}]}],"start":8483},{"state":[{"type":"(↑a : ℚ) / (↑b : ℚ) = (↑q.num : ℚ) / (↑q.den : ℚ)","tag":["convert_5"],"mvarId":["_uniq",207381],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",207129],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",207130],"binderInfo":"default"},{"type":"ℤ","name":["a"],"isProp":false,"id":["_uniq",207131],"binderInfo":"default"},{"type":"ℕ","name":["b"],"isProp":false,"id":["_uniq",207132],"binderInfo":"implicit"},{"type":"b > 0","name":["hb"],"isProp":true,"id":["_uniq",207133],"binderInfo":"default"},{"value":"(↑a : ℚ) / (↑b : ℚ)","type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",207297]}]}],"start":8511},{"state":[],"start":8536},{"state":[],"start":8537},{"state":[],"start":8645},{"state":[],"start":8646},{"state":[],"start":8732},{"state":[],"start":8733},{"state":[],"start":8772},{"state":[{"type":"x ^ q > 0","tag":[],"mvarId":["_uniq",210220],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",210217],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",210218],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",210219],"binderInfo":"default"}]}],"start":8844},{"state":[],"start":8852},{"state":[],"start":8853},{"state":[],"start":8892},{"state":[{"type":"x ^ (q + r) = x ^ q * x ^ r","tag":[],"mvarId":["_uniq",210448],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",210444],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",210445],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",210446],"binderInfo":"default"},{"type":"ℚ","name":["r"],"isProp":false,"id":["_uniq",210447],"binderInfo":"default"}]}],"start":8975},{"state":[],"start":8983},{"state":[],"start":8984},{"state":[],"start":9023},{"state":[{"type":"(x ^ q) ^ r = x ^ (q * r)","tag":[],"mvarId":["_uniq",210627],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",210623],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",210624],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",210625],"binderInfo":"default"},{"type":"ℚ","name":["r"],"isProp":false,"id":["_uniq",210626],"binderInfo":"default"}]}],"start":9107},{"state":[],"start":9115},{"state":[],"start":9116},{"state":[],"start":9155},{"state":[{"type":"x ^ (-q) = 1 / x ^ q","tag":[],"mvarId":["_uniq",210831],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",210828],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",210829],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",210830],"binderInfo":"default"}]}],"start":9233},{"state":[],"start":9241},{"state":[],"start":9242},{"state":[],"start":9281},{"state":[{"type":"x > y ↔ x ^ q > y ^ q","tag":[],"mvarId":["_uniq",211011],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",211005],"binderInfo":"implicit"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",211006],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",211007],"binderInfo":"default"},{"type":"y > 0","name":["hy"],"isProp":true,"id":["_uniq",211008],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",211009],"binderInfo":"implicit"},{"type":"q > 0","name":["h"],"isProp":true,"id":["_uniq",211010],"binderInfo":"default"}]}],"start":9388},{"state":[],"start":9396},{"state":[],"start":9397},{"state":[],"start":9436},{"state":[{"type":"x ^ q > x ^ r ↔ q > r","tag":[],"mvarId":["_uniq",211126],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",211122],"binderInfo":"implicit"},{"type":"x > 1","name":["hx"],"isProp":true,"id":["_uniq",211123],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",211124],"binderInfo":"implicit"},{"type":"ℚ","name":["r"],"isProp":false,"id":["_uniq",211125],"binderInfo":"implicit"}]}],"start":9530},{"state":[],"start":9538},{"state":[],"start":9539},{"state":[],"start":9578},{"state":[{"type":"x ^ q > x ^ r ↔ q < r","tag":[],"mvarId":["_uniq",211285],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",211280],"binderInfo":"implicit"},{"type":"0 < x","name":["hx0"],"isProp":true,"id":["_uniq",211281],"binderInfo":"default"},{"type":"x < 1","name":["hx"],"isProp":true,"id":["_uniq",211282],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",211283],"binderInfo":"implicit"},{"type":"ℚ","name":["r"],"isProp":false,"id":["_uniq",211284],"binderInfo":"implicit"}]}],"start":9685},{"state":[],"start":9693},{"state":[],"start":9694},{"state":[],"start":9733},{"state":[{"type":"(x * y) ^ q = x ^ q * y ^ q","tag":[],"mvarId":["_uniq",211521],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",211516],"binderInfo":"implicit"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",211517],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",211518],"binderInfo":"default"},{"type":"y > 0","name":["hy"],"isProp":true,"id":["_uniq",211519],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",211520],"binderInfo":"default"}]}],"start":9828},{"state":[],"start":9836},{"state":[],"start":9837},{"state":[],"start":9859},{"state":[],"start":9935},{"state":[],"start":9936},{"state":[],"start":9958},{"state":[],"start":10039},{"state":[{"type":"max (x ^ q) y ^ q = max x y ^ q","tag":[],"mvarId":["_uniq",212101],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",212095],"binderInfo":"implicit"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",212096],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",212097],"binderInfo":"default"},{"type":"y > 0","name":["hy"],"isProp":true,"id":["_uniq",212098],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",212099],"binderInfo":"implicit"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",212100],"binderInfo":"default"}]}],"start":10075},{"state":[],"start":10083},{"state":[],"start":10084},{"state":[],"start":10106},{"state":[],"start":10187},{"state":[{"type":"min (x ^ q) y ^ q = min x y ^ q","tag":[],"mvarId":["_uniq",212330],"isProp":true,"context":[{"type":"Real","name":["x"],"isProp":false,"id":["_uniq",212324],"binderInfo":"implicit"},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",212325],"binderInfo":"implicit"},{"type":"x > 0","name":["hx"],"isProp":true,"id":["_uniq",212326],"binderInfo":"default"},{"type":"y > 0","name":["hy"],"isProp":true,"id":["_uniq",212327],"binderInfo":"default"},{"type":"ℚ","name":["q"],"isProp":false,"id":["_uniq",212328],"binderInfo":"implicit"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",212329],"binderInfo":"default"}]}],"start":10223},{"state":[],"start":10231},{"state":[],"start":10232},{"state":[],"start":10343},{"state":[],"start":10344},{"state":[],"start":10357},{"state":[],"start":10357}]
