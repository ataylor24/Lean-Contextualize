[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":79},{"state":[],"start":108},{"state":[],"start":109},{"state":[],"start":110},{"state":[],"start":114},{"state":[],"start":184},{"state":[],"start":185},{"state":[],"start":272},{"state":[],"start":355},{"state":[],"start":444},{"state":[],"start":532},{"state":[],"start":567},{"state":[],"start":568},{"state":[],"start":616},{"state":[],"start":639},{"state":[],"start":640},{"state":[],"start":643},{"state":[],"start":644},{"state":[],"start":664},{"state":[],"start":665},{"state":[],"start":705},{"state":[],"start":706},{"state":[],"start":783},{"state":[],"start":854},{"state":[],"start":935},{"state":[],"start":993},{"state":[],"start":1053},{"state":[],"start":1127},{"state":[{"type":"integ (F * derivWithin G (↑(Icc a b) : Set ℝ)) (Icc a b) =\n  F b * G b - F a * G a - integ (G * derivWithin F (↑(Icc a b) : Set ℝ)) (Icc a b)","tag":[],"mvarId":["_uniq",2076],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",2067],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",2068],"binderInfo":"implicit"},{"type":"a ≤ b","name":["hab"],"isProp":true,"id":["_uniq",2069],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["F"],"isProp":false,"id":["_uniq",2070],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["G"],"isProp":false,"id":["_uniq",2071],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ F (↑(Icc a b) : Set ℝ)","name":["hF"],"isProp":true,"id":["_uniq",2072],"binderInfo":"default"},{"type":"DifferentiableOn ℝ G (↑(Icc a b) : Set ℝ)","name":["hG"],"isProp":true,"id":["_uniq",2073],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin F (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hF'"],"isProp":true,"id":["_uniq",2074],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin G (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hG'"],"isProp":true,"id":["_uniq",2075],"binderInfo":"default"}]}],"start":1183},{"state":[],"start":1193},{"state":[],"start":1194},{"state":[],"start":1284},{"state":[],"start":1343},{"state":[],"start":1374},{"state":[],"start":1447},{"state":[],"start":1507},{"state":[],"start":1549},{"state":[],"start":1609},{"state":[{"type":"IntegrableOn (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  Chapter11.integ (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",3564],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",3562],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",3563],"binderInfo":"default"}]}],"start":1700},{"state":[{"type":"IntegrableOn (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  Chapter11.integ (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",3564],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",3562],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",3563],"binderInfo":"default"}]}],"start":1768},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ Chapter11.integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",4163],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",3563],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"}]}],"start":1806},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ Chapter11.integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",4236],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",3563],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const hf).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]}]}],"start":1883},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ Chapter11.integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",60057],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",3563],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const hf).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"}]}],"start":1939},{"state":[{"type":"Chapter11.integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",60065],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",3563],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const hf).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"}]}],"start":1972},{"state":[{"type":"Chapter11.integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",60074],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"}]}],"start":1995},{"state":[{"type":"∑ J ∈ P.intervals, Chapter11.integ (f * α') J = PiecewiseConstantWith.RS_integ f P α","tag":[],"mvarId":["_uniq",60105],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"}]}],"start":2062},{"state":[{"type":"Chapter11.integ (f * α') J = constant_value_on f (↑J : Set ℝ) * α[J]ₗ","tag":[],"mvarId":["_uniq",60476],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"}]}],"start":2103},{"state":[{"type":"Chapter11.integ (f * α') J = constant_value_on f (↑J : Set ℝ) * α[J]ₗ","tag":[],"mvarId":["_uniq",60476],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"}]}],"start":2110},{"state":[{"type":"Chapter11.integ (f * α') J = Chapter11.integ (constant_value_on f (↑J : Set ℝ) • α') J","tag":[],"mvarId":["_uniq",60637],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"}]}],"start":2186},{"state":[{"type":"(f * α') x = (constant_value_on f (↑J : Set ℝ) • α') x","tag":["h"],"mvarId":["_uniq",60909],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",60905],"binderInfo":"strictImplicit"},{"type":"x ∈ (↑J : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",60908],"binderInfo":"default"}]}],"start":2232},{"state":[{"type":"f x = constant_value_on f (↑J : Set ℝ)","tag":["h","e_a"],"mvarId":["_uniq",61318],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",60905],"binderInfo":"strictImplicit"},{"type":"x ∈ (↑J : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",60908],"binderInfo":"default"}]}],"start":2298},{"state":[],"start":2326},{"state":[],"start":2435},{"state":[{"type":"constant_value_on f (↑J : Set ℝ) * Chapter11.integ α' J = constant_value_on f (↑J : Set ℝ) * α[J]ₗ","tag":[],"mvarId":["_uniq",60838],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"}]}],"start":2451},{"state":[{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",61651],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"}]}],"start":2463},{"state":[{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",62250],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]}]}],"start":2536},{"state":[{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",62250],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]}]}],"start":2617},{"state":[{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","inl","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",69862],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"0 = J.length","name":["hJab"],"isProp":true,"id":["_uniq",69861],"binderInfo":"default"}]},{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",69867],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"0 < J.length","name":["hJab"],"isProp":true,"id":["_uniq",69866],"binderInfo":"default"}]}],"start":2682},{"state":[{"type":"0 = α[J]ₗ","tag":["e_a","inl","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",69892],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"0 = J.length","name":["hJab"],"isProp":true,"id":["_uniq",69861],"binderInfo":"default"}]}],"start":2731},{"state":[{"type":"0 = α[J]ₗ","tag":["e_a","inl","inl","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",73739],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.b < J.a","name":["hJab"],"isProp":true,"id":["_uniq",73738],"binderInfo":"default"}]},{"type":"0 = α[J]ₗ","tag":["e_a","inl","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",73744],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.b - J.a = 0","name":["hJab"],"isProp":true,"id":["_uniq",73743],"binderInfo":"default"}]}],"start":2798},{"state":[{"type":"0 = α[J]ₗ","tag":["e_a","inl","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",73744],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.b - J.a = 0","name":["hJab"],"isProp":true,"id":["_uniq",73743],"binderInfo":"default"}]}],"start":2853},{"state":[{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",69867],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"0 < J.length","name":["hJab"],"isProp":true,"id":["_uniq",69866],"binderInfo":"default"}]}],"start":2930},{"state":[{"type":"Chapter11.integ α' J = α[J]ₗ","tag":["e_a","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",138149],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]}],"start":2958},{"state":[{"type":"Chapter11.integ α' J = α J.b - α J.a","tag":["e_a","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",138245],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.a - 1 < J.a","tag":[],"mvarId":["_uniq",138154],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.a ≤ J.b","tag":[],"mvarId":["_uniq",138155],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.b < J.b + 1","tag":[],"mvarId":["_uniq",138156],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.a ≤ J.b","tag":[],"mvarId":["_uniq",138157],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]}],"start":3028},{"state":[{"type":"Icc J.a J.b ⊆ Icc a b","tag":[],"mvarId":["_uniq",138268],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]}],"start":3073},{"state":[{"type":"Icc J.a J.b ⊆ Icc a b","tag":[],"mvarId":["_uniq",138482],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"},{"value":"closure_mono ((subset_iff (Ioo J.a J.b) (Icc a b)).mp (HasSubset.Subset.trans (Ioo_subset J) (P.contains J hJ)))","type":"closure (↑(Ioo J.a J.b) : Set ℝ) ⊆ closure (↑(Icc a b) : Set ℝ)","name":["this"],"isProp":true,"id":["_uniq",138481]}]}],"start":3167},{"state":[{"type":"Chapter11.integ α' J = α J.b - α J.a","tag":["e_a","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",138270],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"},{"value":"have this :=\n  closure_mono ((subset_iff (Ioo J.a J.b) (Icc a b)).mp (HasSubset.Subset.trans (Ioo_subset J) (P.contains J hJ)));\nEq.mpr\n  (id\n    (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Icc a b))\n      (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Icc a b))))\n  (Eq.mp\n    (_root_.congr\n      (congrArg Subset\n        (Eq.trans (congrArg closure (set_Ioo J.a J.b))\n          (closure_Ioo\n            (have this :=\n              Not.intro fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                            (Mathlib.Tactic.Ring.atom_pf J.b)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.neg_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                              (Mathlib.Tactic.Ring.atom_pf J.b)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul J.a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero)))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero J.a (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero J.b (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                    (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt hJab)\n                      (neg_eq_zero.mpr (sub_eq_zero_of_eq a))));\n            this))))\n      (Eq.trans (congrArg closure (set_Icc a b)) (closure_Icc a b)))\n    this)","type":"Icc J.a J.b ⊆ Icc a b","name":["this"],"isProp":true,"id":["_uniq",138269]}]}],"start":3251},{"state":[{"type":"Chapter11.integ α' J = α J.b - α J.a","tag":["e_a","inr","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",138270],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"},{"value":"have this :=\n  closure_mono ((subset_iff (Ioo J.a J.b) (Icc a b)).mp (HasSubset.Subset.trans (Ioo_subset J) (P.contains J hJ)));\nEq.mpr\n  (id\n    (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Icc a b))\n      (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Icc a b))))\n  (Eq.mp\n    (_root_.congr\n      (congrArg Subset\n        (Eq.trans (congrArg closure (set_Ioo J.a J.b))\n          (closure_Ioo\n            (have this :=\n              Not.intro fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                            (Mathlib.Tactic.Ring.atom_pf J.b)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.neg_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                              (Mathlib.Tactic.Ring.atom_pf J.b)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul J.a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero)))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero J.a (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero J.b (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                    (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt hJab)\n                      (neg_eq_zero.mpr (sub_eq_zero_of_eq a))));\n            this))))\n      (Eq.trans (congrArg closure (set_Icc a b)) (closure_Icc a b)))\n    this)","type":"Icc J.a J.b ⊆ Icc a b","name":["this"],"isProp":true,"id":["_uniq",138269]}]}],"start":3264},{"state":[],"start":3359},{"state":[{"type":"Chapter11.integ α' (Icc J.a J.b) = α J.b - α J.a","tag":[],"mvarId":["_uniq",148533],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"},{"value":"have this :=\n  closure_mono ((subset_iff (Ioo J.a J.b) (Icc a b)).mp (HasSubset.Subset.trans (Ioo_subset J) (P.contains J hJ)));\nEq.mpr\n  (id\n    (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Icc a b))\n      (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Icc a b))))\n  (Eq.mp\n    (_root_.congr\n      (congrArg Subset\n        (Eq.trans (congrArg closure (set_Ioo J.a J.b))\n          (closure_Ioo\n            (have this :=\n              Not.intro fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                            (Mathlib.Tactic.Ring.atom_pf J.b)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.neg_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                              (Mathlib.Tactic.Ring.atom_pf J.b)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul J.a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero)))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero J.a (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero J.b (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                    (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt hJab)\n                      (neg_eq_zero.mpr (sub_eq_zero_of_eq a))));\n            this))))\n      (Eq.trans (congrArg closure (set_Icc a b)) (closure_Icc a b)))\n    this)","type":"Icc J.a J.b ⊆ Icc a b","name":["this"],"isProp":true,"id":["_uniq",138269]}]}],"start":3381},{"state":[{"type":"AntiderivOn α α' (Icc J.a J.b)","tag":["convert_2"],"mvarId":["_uniq",148644],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"},{"value":"have this :=\n  closure_mono ((subset_iff (Ioo J.a J.b) (Icc a b)).mp (HasSubset.Subset.trans (Ioo_subset J) (P.contains J hJ)));\nEq.mpr\n  (id\n    (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Icc a b))\n      (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Icc a b))))\n  (Eq.mp\n    (_root_.congr\n      (congrArg Subset\n        (Eq.trans (congrArg closure (set_Ioo J.a J.b))\n          (closure_Ioo\n            (have this :=\n              Not.intro fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                            (Mathlib.Tactic.Ring.atom_pf J.b)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.neg_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                              (Mathlib.Tactic.Ring.atom_pf J.b)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul J.a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero)))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero J.a (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero J.b (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                    (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt hJab)\n                      (neg_eq_zero.mpr (sub_eq_zero_of_eq a))));\n            this))))\n      (Eq.trans (congrArg closure (set_Icc a b)) (closure_Icc a b)))\n    this)","type":"Icc J.a J.b ⊆ Icc a b","name":["this"],"isProp":true,"id":["_uniq",138269]}]}],"start":3455},{"state":[{"type":"∀ x ∈ Icc a b, HasDerivWithinAt α (α' x) (↑(Icc a b) : Set ℝ) x","tag":[],"mvarId":["_uniq",151853],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"},{"value":"have this :=\n  closure_mono ((subset_iff (Ioo J.a J.b) (Icc a b)).mp (HasSubset.Subset.trans (Ioo_subset J) (P.contains J hJ)));\nEq.mpr\n  (id\n    (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Icc a b))\n      (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Icc a b))))\n  (Eq.mp\n    (_root_.congr\n      (congrArg Subset\n        (Eq.trans (congrArg closure (set_Ioo J.a J.b))\n          (closure_Ioo\n            (have this :=\n              Not.intro fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                            (Mathlib.Tactic.Ring.atom_pf J.b)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.neg_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf J.a)\n                              (Mathlib.Tactic.Ring.atom_pf J.b)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (J.a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (J.b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul J.a (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul J.b (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero)))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero J.a (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero J.b (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                    (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt hJab)\n                      (neg_eq_zero.mpr (sub_eq_zero_of_eq a))));\n            this))))\n      (Eq.trans (congrArg closure (set_Icc a b)) (closure_Icc a b)))\n    this)","type":"Icc J.a J.b ⊆ Icc a b","name":["this"],"isProp":true,"id":["_uniq",138269]}]}],"start":3515},{"state":[{"type":"J.a - 1 < J.a","tag":[],"mvarId":["_uniq",138154],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.a ≤ J.b","tag":[],"mvarId":["_uniq",138155],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.b < J.b + 1","tag":[],"mvarId":["_uniq",138156],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]},{"type":"J.a ≤ J.b","tag":[],"mvarId":["_uniq",138157],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",3556],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",3557],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",3558],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",3559],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",3560],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",3561],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",4090]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",4160],"binderInfo":"default"},{"value":"(integ_of_piecewise_const _fvar.3563).left","type":"IntegrableOn f (Icc a b)","name":["hf_integ"],"isProp":true,"id":["_uniq",4235]},{"type":"IntegrableOn (f * α') (Icc a b)","name":["hfα'_integ"],"isProp":true,"id":["_uniq",60056],"binderInfo":"default"},{"type":"Partition (Icc a b)","name":["P"],"isProp":false,"id":["_uniq",60067],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P","name":["hP"],"isProp":true,"id":["_uniq",60071],"binderInfo":"default"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",60472],"binderInfo":"default"},{"type":"J ∈ P.intervals","name":["hJ"],"isProp":true,"id":["_uniq",60475],"binderInfo":"default"},{"value":"fun hJab =>\n  HasSubset.Subset.trans (subset_Icc J)\n    (of_eq_true\n      (Eq.trans (RS_integ_eq_integ_of_mul_deriv._simp_1 (Icc J.a J.b) (Ioo (J.a - 1) (J.b + 1)))\n        (Eq.trans\n          (Eq.trans (_root_.congr (congrArg Subset (set_Icc J.a J.b)) (set_Ioo (J.a - 1) (J.b + 1)))\n            ((fun x_0 x_1 => propext ((fun x_0 x_1 => Set.Icc_subset_Ioo_iff hJab) x_0 x_1)) (J.a - 1) (J.b + 1)))\n          (Eq.trans\n            (_root_.congr (congrArg And (Eq.trans (div_lt_self_iff._simp_4 J.a) zero_lt_one._simp_1))\n              (Eq.trans (lt_mul_iff_one_lt_right'._simp_4 J.b) zero_lt_one._simp_1))\n            (and_self True)))))","type":"J.a ≤ J.b → J ⊆ Ioo (J.a - 1) (J.b + 1)","name":["hJsub"],"isProp":true,"id":["_uniq",62248]},{"type":"J.a < J.b","name":["hJab"],"isProp":true,"id":["_uniq",138146],"binderInfo":"default"}]}],"start":3591},{"state":[],"start":3616},{"state":[],"start":3617},{"state":[],"start":3642},{"state":[],"start":3681},{"state":[],"start":3744},{"state":[],"start":3817},{"state":[],"start":3877},{"state":[],"start":3918},{"state":[],"start":3978},{"state":[{"type":"IntegrableOn (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",157672],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",157670],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"}]}],"start":4059},{"state":[{"type":"IntegrableOn (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (f * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",157672],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",157670],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"}]}],"start":4127},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",158271],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"}]}],"start":4165},{"state":[{"type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","tag":[],"mvarId":["_uniq",158461],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"}]}],"start":4217},{"state":[{"type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","tag":[],"mvarId":["_uniq",158705],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",158518],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Icc a b) : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",158519],"binderInfo":"default"},{"type":"ℝ","name":["N"],"isProp":false,"id":["_uniq",158696],"binderInfo":"default"},{"type":"∀ x ∈ (↑(Icc a b) : Set ℝ), |α' x| ≤ N","name":["hN"],"isProp":true,"id":["_uniq",158697],"binderInfo":"default"}]}],"start":4278},{"state":[{"type":"|(f * α') x| ≤ M * N","tag":["h"],"mvarId":["_uniq",159009],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",158518],"binderInfo":"default"},{"type":"ℝ","name":["N"],"isProp":false,"id":["_uniq",158696],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",158933],"binderInfo":"default"},{"type":"x ∈ (↑(Icc a b) : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",158936],"binderInfo":"default"},{"type":"|f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",158976],"binderInfo":"default"},{"type":"|α' x| ≤ N","name":["hN"],"isProp":true,"id":["_uniq",159006],"binderInfo":"default"}]}],"start":4344},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",158463],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]}]}],"start":4400},{"state":[{"type":"MajorizesOn α' 0 (Icc a b)","tag":[],"mvarId":["_uniq",178370],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]}]}],"start":4455},{"state":[{"type":"0 x ≤ α' x","tag":[],"mvarId":["_uniq",178383],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"x ∈ (↑(Icc a b) : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",178382],"binderInfo":"default"}]}],"start":4470},{"state":[{"type":"ClusterPt x (Filter.principal ((↑(Icc a b) : Set ℝ) \\ {x}))","tag":[],"mvarId":["_uniq",178458],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"x ∈ (↑(Icc a b) : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",178382],"binderInfo":"default"}]}],"start":4544},{"state":[{"type":"x ∈ closure ((↑(Icc a b) : Set ℝ) \\ {x})","tag":[],"mvarId":["_uniq",179765],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"x ∈ (↑(Icc a b) : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",178382],"binderInfo":"default"}]}],"start":4582},{"state":[{"type":"x ∈ closure ((↑(Icc a b) : Set ℝ) \\ {x})","tag":[],"mvarId":["_uniq",181838],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"}]}],"start":4597},{"state":[{"type":"x ∈ closure ((↑(Icc a b) : Set ℝ) \\ {x})","tag":["inl"],"mvarId":["_uniq",182000],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a < x","name":["h"],"isProp":true,"id":["_uniq",181999],"binderInfo":"default"}]},{"type":"x ∈ closure ((↑(Icc a b) : Set ℝ) \\ {x})","tag":["inr"],"mvarId":["_uniq",182005],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a = x","name":["h"],"isProp":true,"id":["_uniq",182004],"binderInfo":"default"}]}],"start":4641},{"state":[{"type":"x ∈ closure (Set.Ico a x)","tag":["inl","a"],"mvarId":["_uniq",182076],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a < x","name":["h"],"isProp":true,"id":["_uniq",181999],"binderInfo":"default"}]},{"type":"Set.Ico a x ⊆ (↑(Icc a b) : Set ℝ) \\ {x}","tag":[],"mvarId":["_uniq",182068],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a < x","name":["h"],"isProp":true,"id":["_uniq",181999],"binderInfo":"default"}]}],"start":4684},{"state":[{"type":"Set.Ico a x ⊆ (↑(Icc a b) : Set ℝ) \\ {x}","tag":[],"mvarId":["_uniq",182068],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a < x","name":["h"],"isProp":true,"id":["_uniq",181999],"binderInfo":"default"}]}],"start":4744},{"state":[{"type":"x ∈ closure ((↑(Icc a b) : Set ℝ) \\ {x})","tag":["inr"],"mvarId":["_uniq",182005],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a = x","name":["h"],"isProp":true,"id":["_uniq",182004],"binderInfo":"default"}]}],"start":4777},{"state":[{"type":"x ∈ closure (Set.Ioc x b)","tag":["inr","a"],"mvarId":["_uniq",211378],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a = x","name":["h"],"isProp":true,"id":["_uniq",182004],"binderInfo":"default"}]},{"type":"Set.Ioc x b ⊆ (↑(Icc a b) : Set ℝ) \\ {x}","tag":[],"mvarId":["_uniq",211339],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a = x","name":["h"],"isProp":true,"id":["_uniq",182004],"binderInfo":"default"}]}],"start":4818},{"state":[{"type":"Set.Ioc x b ⊆ (↑(Icc a b) : Set ℝ) \\ {x}","tag":[],"mvarId":["_uniq",211339],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",178379],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",181835],"binderInfo":"default"},{"type":"a = x","name":["h"],"isProp":true,"id":["_uniq",182004],"binderInfo":"default"}]}],"start":4876},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",178374],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]}]}],"start":4900},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",223841],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]}]}],"start":4918},{"state":[{"type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","tag":[],"mvarId":["_uniq",223961],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]}]}],"start":4999},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",224112],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"}]}],"start":5043},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",224268],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["hh"],"isProp":true,"id":["_uniq",224262],"binderInfo":"default"}]}],"start":5087},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",224268],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["hh"],"isProp":true,"id":["_uniq",224262],"binderInfo":"default"}]}],"start":5212},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",225153],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["hh"],"isProp":true,"id":["_uniq",224262],"binderInfo":"default"},{"value":"PiecewiseConstantOn.RS_integ_eq_integ_of_mul_deriv hα_diff hαcont hα' hhconst","type":"IntegrableOn (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["this"],"isProp":true,"id":["_uniq",225152]}]}],"start":5285},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",225174],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hh"],"isProp":true,"id":["_uniq",225168],"binderInfo":"default"},{"type":"IntegrableOn (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["this"],"isProp":true,"id":["_uniq",225171],"binderInfo":"default"}]}],"start":5310},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",225380],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hh"],"isProp":true,"id":["_uniq",225168],"binderInfo":"default"},{"type":"lower_integral (h * α') (Icc a b) = integ (h * α') (Icc a b)","name":["this"],"isProp":true,"id":["_uniq",225376]}]}],"start":5399},{"state":[{"type":"lower_integral (h * α') (Icc a b) ≤ lower_integral (f * α') (Icc a b)","tag":[],"mvarId":["_uniq",225496],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hh"],"isProp":true,"id":["_uniq",225168],"binderInfo":"default"},{"type":"lower_integral (h * α') (Icc a b) = integ (h * α') (Icc a b)","name":["this"],"isProp":true,"id":["_uniq",225376]}]}],"start":5494},{"state":[{"type":"RS_integ f (Icc a b) α - ε ≤ lower_integral (f * α') (Icc a b)","tag":["h"],"mvarId":["_uniq",225498],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",224108],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",224111],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",224257],"binderInfo":"default"},{"type":"MinorizesOn h f (Icc a b)","name":["hhminor"],"isProp":true,"id":["_uniq",224258],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",224261],"binderInfo":"default"},{"type":"RS_integ f (Icc a b) α - ε < integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hh"],"isProp":true,"id":["_uniq",225168],"binderInfo":"default"},{"type":"lower_integral (h * α') (Icc a b) = integ (h * α') (Icc a b)","name":["this"],"isProp":true,"id":["_uniq",225376]},{"value":"sorry","type":"lower_integral (h * α') (Icc a b) ≤ lower_integral (f * α') (Icc a b)","name":["why"],"isProp":true,"id":["_uniq",225497]}]}],"start":5506},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",223963],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]}]}],"start":5519},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",226391],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]}]}],"start":5600},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α + ε","tag":["h"],"mvarId":["_uniq",226776],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"}]}],"start":5648},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α + ε","tag":["h"],"mvarId":["_uniq",226931],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",226920],"binderInfo":"default"},{"type":"MajorizesOn h f (Icc a b)","name":["hhmajor"],"isProp":true,"id":["_uniq",226921],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",226924],"binderInfo":"default"},{"type":"PiecewiseConstantOn.RS_integ h (Icc a b) α < upper_RS_integral f (Icc a b) α + ε","name":["hh"],"isProp":true,"id":["_uniq",226925],"binderInfo":"default"}]}],"start":5692},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α + ε","tag":["h"],"mvarId":["_uniq",226931],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",226920],"binderInfo":"default"},{"type":"MajorizesOn h f (Icc a b)","name":["hhmajor"],"isProp":true,"id":["_uniq",226921],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",226924],"binderInfo":"default"},{"type":"PiecewiseConstantOn.RS_integ h (Icc a b) α < upper_RS_integral f (Icc a b) α + ε","name":["hh"],"isProp":true,"id":["_uniq",226925],"binderInfo":"default"}]}],"start":5817},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α + ε","tag":["h"],"mvarId":["_uniq",227847],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",226920],"binderInfo":"default"},{"type":"MajorizesOn h f (Icc a b)","name":["hhmajor"],"isProp":true,"id":["_uniq",226921],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",226924],"binderInfo":"default"},{"type":"PiecewiseConstantOn.RS_integ h (Icc a b) α < upper_RS_integral f (Icc a b) α + ε","name":["hh"],"isProp":true,"id":["_uniq",226925],"binderInfo":"default"},{"value":"PiecewiseConstantOn.RS_integ_eq_integ_of_mul_deriv hα_diff hαcont hα' hhconst","type":"IntegrableOn (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["this"],"isProp":true,"id":["_uniq",227846]}]}],"start":5890},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α + ε","tag":["h"],"mvarId":["_uniq",227868],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",226920],"binderInfo":"default"},{"type":"MajorizesOn h f (Icc a b)","name":["hhmajor"],"isProp":true,"id":["_uniq",226921],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",226924],"binderInfo":"default"},{"type":"integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) < upper_RS_integral f (Icc a b) α + ε","name":["hh"],"isProp":true,"id":["_uniq",227862],"binderInfo":"default"},{"type":"IntegrableOn (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["this"],"isProp":true,"id":["_uniq",227865],"binderInfo":"default"}]}],"start":5915},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ upper_integral (h * α') (Icc a b)","tag":[],"mvarId":["_uniq",228049],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",226920],"binderInfo":"default"},{"type":"MajorizesOn h f (Icc a b)","name":["hhmajor"],"isProp":true,"id":["_uniq",226921],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",226924],"binderInfo":"default"},{"type":"integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) < upper_RS_integral f (Icc a b) α + ε","name":["hh"],"isProp":true,"id":["_uniq",227862],"binderInfo":"default"},{"type":"IntegrableOn (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["this"],"isProp":true,"id":["_uniq",227865],"binderInfo":"default"}]}],"start":6010},{"state":[{"type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α + ε","tag":["h"],"mvarId":["_uniq",228051],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",226772],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",226775],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",226920],"binderInfo":"default"},{"type":"MajorizesOn h f (Icc a b)","name":["hhmajor"],"isProp":true,"id":["_uniq",226921],"binderInfo":"default"},{"type":"PiecewiseConstantOn h (Icc a b)","name":["hhconst"],"isProp":true,"id":["_uniq",226924],"binderInfo":"default"},{"type":"integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) < upper_RS_integral f (Icc a b) α + ε","name":["hh"],"isProp":true,"id":["_uniq",227862],"binderInfo":"default"},{"type":"IntegrableOn (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) = PiecewiseConstantOn.RS_integ h (Icc a b) α","name":["this"],"isProp":true,"id":["_uniq",227865],"binderInfo":"default"},{"value":"sorry","type":"upper_integral (f * α') (Icc a b) ≤ upper_integral (h * α') (Icc a b)","name":["why"],"isProp":true,"id":["_uniq",228050]}]}],"start":6022},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",226393],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  match\n    lt_of_gt_upper_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)));\n      this) with\n  | ⋯ =>\n    have this := PiecewiseConstantOn.RS_integ_eq_integ_of_mul_deriv hα_diff hαcont hα' hhconst;\n    have why := sorry;\n    le_of_not_gt fun a_1 =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.atom_pf (integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                            (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf ⋯) ⋯ ⋯) ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)","type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α","name":["h2"],"isProp":true,"id":["_uniq",226392]}]}],"start":6035},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",229046],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  match\n    lt_of_gt_upper_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)));\n      this) with\n  | ⋯ =>\n    have this := PiecewiseConstantOn.RS_integ_eq_integ_of_mul_deriv hα_diff hαcont hα' hhconst;\n    have why := sorry;\n    le_of_not_gt fun a_1 =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.atom_pf (integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                            (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf ⋯) ⋯ ⋯) ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)","type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α","name":["h2"],"isProp":true,"id":["_uniq",226392]},{"value":"lower_integral_le_upper hfα'_bound","type":"lower_integral (f * α') (Icc a b) ≤ upper_integral (f * α') (Icc a b)","name":["h3"],"isProp":true,"id":["_uniq",229045]}]}],"start":6086},{"state":[{"type":"IntegrableOn (f * α') (Icc a b) ∧ integ (f * α') (Icc a b) = RS_integ f (Icc a b) α","tag":[],"mvarId":["_uniq",229046],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",157662],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",157663],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",157664],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["α"],"isProp":false,"id":["_uniq",157665],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",157666],"binderInfo":"implicit"},{"type":"Monotone α","name":["hα"],"isProp":true,"id":["_uniq",157667],"binderInfo":"default"},{"type":"DifferentiableOn ℝ α (↑(Icc a b) : Set ℝ)","name":["hα_diff"],"isProp":true,"id":["_uniq",157668],"binderInfo":"default"},{"type":"Continuous α","name":["hαcont"],"isProp":true,"id":["_uniq",157669],"binderInfo":"default"},{"type":"RS_IntegrableOn f (Icc a b) α","name":["hf"],"isProp":true,"id":["_uniq",157671],"binderInfo":"default"},{"value":"derivWithin α (↑(Icc a b) : Set ℝ)","type":"ℝ → ℝ","name":["α'"],"isProp":false,"id":["_uniq",158198]},{"type":"IntegrableOn α' (Icc a b)","name":["hα'"],"isProp":true,"id":["_uniq",158268],"binderInfo":"default"},{"value":"match hf.left with\n| Exists.intro M hM =>\n  match hα'.left with\n  | Exists.intro N hN =>\n    Exists.intro (M * N) fun x hx =>\n      Eq.mpr (id (congrArg (fun x => x ≤ M * N) (abs_mul (f x) (α' x))))\n        (mul_le_mul (hM x hx) (hN x hx) (IsAbsoluteValue.abv_nonneg abs (α' x))\n          (le_of_not_gt fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf |f x|)\n                          (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf M)\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (|f x| ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf |f x|)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul |f x| (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (|f x| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero |f x| (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                  (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le (hM x hx))\n                    (Mathlib.Tactic.Linarith.sub_neg_of_lt a))\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le (abs_nonneg (f x)))))))","type":"BddOn (f * α') (↑(Icc a b) : Set ℝ)","name":["hfα'_bound"],"isProp":true,"id":["_uniq",158462]},{"value":"fun x hx =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (0 x) 0 (Eq.refl (0 x)) (α' x)))\n    (ge_iff_le.mp\n      (derivative_of_monotone (↑(Icc a b) : Set ℝ)\n        (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext mem_closure_iff_clusterPt))))\n          (Or.casesOn\n            (le_iff_lt_or_eq.mp\n              (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx).left)\n            (fun h =>\n              closure_mono\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (fun x_1 => a_1 ∈ x_1 \\ {x}) (set_Icc a b)) (Set.mem_diff._simp_1 a_1))\n                        (congr\n                          (congrArg And\n                            (Eq.trans Set.mem_Icc._simp_1\n                              (Eq.trans\n                                (congrArg (fun x => x ∧ a_1 ≤ b) (eq_true (id (Eq.mp Set.mem_Ico._simp_1 a_2)).1))\n                                (true_and (a_1 ≤ b)))))\n                          (congrArg Not Set.mem_singleton_iff._simp_1))))\n                    (RS_integ_eq_integ_of_mul_deriv._proof_3 x hf hα'\n                      (Eq.mp (congrArg (BddOn (f * α')) (set_Icc a b)) hfα'_bound)\n                      (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) hx) h\n                      (Eq.mp Set.mem_Ico._simp_1 a_2)))\n                (of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x_1 => x ∈ x_1)\n                        (closure_Ico\n                          (have this :=\n                            Not.intro fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf x)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_congr\n                                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                            (Mathlib.Tactic.Ring.atom_pf x)\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                  (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 1)))))))\n                                              Mathlib.Tactic.Ring.neg_zero)))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero\n                                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                  (Mathlib.Tactic.Linarith.lt_of_lt_of_eq (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n                                    (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                          this)))\n                      Set.mem_Icc._simp_1)\n                    (Eq.trans\n                      (congr\n                        (congrArg And\n                          (eq_true\n                            (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1)\n                                hx).left))\n                        (le_refl._simp_1 x))\n                      (and_self True)))))\n            fun h =>\n            closure_mono\n              (fun ⦃a_1⦄ a_2 =>\n                of_eq_true\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (fun x => a_1 ∈ x)\n                        (Eq.trans\n                          (congrArg (fun x_1 => x_1 \\ {x})\n                            (Eq.trans (congrArg (fun x => (↑(Icc x b) : Set ℝ)) h) (set_Icc x b)))\n                          Set.Icc_diff_left))\n                      Set.mem_Ioc._simp_1)\n                    (Eq.trans (congr (congrArg And (eq_true (id (Eq.mp Set.mem_Ioc._simp_1 a_2)).1)) (eq_true (id ⋯).2))\n                      ⋯)))\n              ⋯))\n        ⋯ ⋯))","type":"MajorizesOn α' 0 (Icc a b)","name":["hα'_nonneg"],"isProp":true,"id":["_uniq",178371]},{"value":"hf.right","type":"lower_RS_integral f (Icc a b) α = upper_RS_integral f (Icc a b) α","name":["h0"],"isProp":true,"id":["_uniq",223840]},{"value":"le_of_forall_sub_le fun ε hε =>\n  match\n    gt_of_lt_lower_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero ⋯ ⋯))\n                  ⋯))\n              ⋯);\n      ⋯) with\n  | ⋯ => ⋯","type":"RS_integ f (Icc a b) α ≤ lower_integral (f * α') (Icc a b)","name":["h1"],"isProp":true,"id":["_uniq",223962]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  match\n    lt_of_gt_upper_RS_integral hf.left hα\n      (have this :=\n        lt_of_not_ge fun a_1 =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (RS_integ f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le a_1)));\n      this) with\n  | ⋯ =>\n    have this := PiecewiseConstantOn.RS_integ_eq_integ_of_mul_deriv hα_diff hαcont hα' hhconst;\n    have why := sorry;\n    le_of_not_gt fun a_1 =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.atom_pf (integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b)))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral f (Icc a b) α))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral f (Icc a b) α) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (integ (h * derivWithin α (↑(Icc a b) : Set ℝ)) (Icc a b) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (upper_RS_integral f (Icc a b) α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                            (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf ⋯) ⋯ ⋯) ⋯)\n                ⋯ ⋯)\n              ⋯))\n          ⋯)","type":"upper_integral (f * α') (Icc a b) ≤ RS_integ f (Icc a b) α","name":["h2"],"isProp":true,"id":["_uniq",226392]},{"value":"lower_integral_le_upper hfα'_bound","type":"lower_integral (f * α') (Icc a b) ≤ upper_integral (f * α') (Icc a b)","name":["h3"],"isProp":true,"id":["_uniq",229045]}]}],"start":6164},{"state":[],"start":6222},{"state":[],"start":6223},{"state":[],"start":6262},{"state":[],"start":6349},{"state":[],"start":6451},{"state":[],"start":6533},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",230466],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",230465],"binderInfo":"default"}]}],"start":6571},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",230466],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"PiecewiseConstantOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",230465],"binderInfo":"default"}]}],"start":6639},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",230475],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P'","name":["hf"],"isProp":true,"id":["_uniq",230472],"binderInfo":"default"}]}],"start":6663},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",230483],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P'","name":["hf"],"isProp":true,"id":["_uniq",230472],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]}]}],"start":6690},{"state":[{"type":"PiecewiseConstantWith f P","tag":[],"mvarId":["_uniq",230593],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"type":"PiecewiseConstantWith f P'","name":["hf"],"isProp":true,"id":["_uniq",230472],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]}]}],"start":6737},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",230954],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]}]}],"start":6835},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧ RS_integ (f ∘ φ) (Icc a b) φ = PiecewiseConstantWith.integ f P","tag":[],"mvarId":["_uniq",230966],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]}]}],"start":6855},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",230971],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]}]}],"start":6892},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",231270],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]}]}],"start":6999},{"state":[{"type":"Bornology.IsBounded (φ_inv J)","tag":[],"mvarId":["_uniq",231483],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",231440],"binderInfo":"default"}]}],"start":7078},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",231487],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]}]}],"start":7149},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",242219],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]}]}],"start":7229},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",242284],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]}]}],"start":7386},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",242634],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]}]}],"start":7444},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",242634],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]}]}],"start":7549},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",242664],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]}]}],"start":7623},{"state":[{"type":"ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n  constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","tag":[],"mvarId":["_uniq",242937],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",242688],"binderInfo":"implicit"}]}],"start":7771},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",242940],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]}]}],"start":7781},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243352],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]}]}],"start":7816},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243352],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]}]}],"start":7854},{"state":[],"start":7886},{"state":[],"start":7916},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243352],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]}]}],"start":7920},{"state":[{"type":"PiecewiseConstantWith (f ∘ φ) Q","tag":[],"mvarId":["_uniq",243553],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]}]}],"start":7985},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243557],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]}]}],"start":7995},{"state":[{"type":"PiecewiseConstantOn (f ∘ φ) (Icc a b) ∧\n  RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243596],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8090},{"state":[{"type":"RS_integ (f ∘ φ) (Icc a b) φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243607],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8128},{"state":[{"type":"PiecewiseConstantWith.RS_integ (f ∘ φ) Q φ = ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243628],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8163},{"state":[{"type":"∑ J ∈ Q.intervals, constant_value_on (f ∘ φ) (↑J : Set ℝ) * φ[J]ₗ =\n  ∑ J ∈ P.intervals, constant_value_on f (↑J : Set ℝ) * J.length","tag":[],"mvarId":["_uniq",243645],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8203},{"state":[{"type":"∑ x, constant_value_on (f ∘ φ) (↑(φ_inv' x) : Set ℝ) * φ[φ_inv' x]ₗ =\n  ∑ i, constant_value_on f (↑(↑i : BoundedInterval) : Set ℝ) * (↑i : BoundedInterval).length","tag":[],"mvarId":["_uniq",244553],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]},{"type":"Set.InjOn φ_inv' (↑Finset.univ : Set { x // x ∈ P.intervals })","tag":[],"mvarId":["_uniq",244179],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8270},{"state":[{"type":"∀ x ∈ Finset.univ,\n  constant_value_on (f ∘ φ) (↑(φ_inv' x) : Set ℝ) * φ[φ_inv' x]ₗ =\n    constant_value_on f (↑(↑x : BoundedInterval) : Set ℝ) * (↑x : BoundedInterval).length","tag":[],"mvarId":["_uniq",244940],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8301},{"state":[{"type":"constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) * φ[φ_inv' J]ₗ =\n  constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ) * (↑J : BoundedInterval).length","tag":[],"mvarId":["_uniq",244965],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",244961],"binderInfo":"default"},{"type":"J ∈ Finset.univ","name":["a✝"],"isProp":true,"id":["_uniq",244964],"binderInfo":"default"}]}],"start":8315},{"state":[{"type":"constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","tag":["e_a","_@","Init","Prelude","_hyg",2164],"mvarId":["_uniq",245059],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",244961],"binderInfo":"default"},{"type":"J ∈ Finset.univ","name":["a✝"],"isProp":true,"id":["_uniq",244964],"binderInfo":"default"}]},{"type":"φ[φ_inv' J]ₗ = (↑J : BoundedInterval).length","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",245060],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",244961],"binderInfo":"default"},{"type":"J ∈ Finset.univ","name":["a✝"],"isProp":true,"id":["_uniq",244964],"binderInfo":"default"}]}],"start":8327},{"state":[{"type":"φ[φ_inv' J]ₗ = (↑J : BoundedInterval).length","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",245060],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",244961],"binderInfo":"default"},{"type":"J ∈ Finset.univ","name":["a✝"],"isProp":true,"id":["_uniq",244964],"binderInfo":"default"}]}],"start":8355},{"state":[{"type":"Set.InjOn φ_inv' (↑Finset.univ : Set { x // x ∈ P.intervals })","tag":[],"mvarId":["_uniq",244179],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]}]}],"start":8365},{"state":[{"type":"J = K","tag":[],"mvarId":["_uniq",245406],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"}]}],"start":8385},{"state":[{"type":"J = K","tag":[],"mvarId":["_uniq",245420],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]}]}],"start":8422},{"state":[{"type":"J = K","tag":[],"mvarId":["_uniq",245769],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"value":"Set.Nonempty.some_mem (hφ_inv_nonempty J)","type":"x ∈ φ_inv J","name":["h1"],"isProp":true,"id":["_uniq",245768]}]}],"start":8482},{"state":[{"type":"J = K","tag":[],"mvarId":["_uniq",245841],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"value":"Set.Nonempty.some_mem (hφ_inv_nonempty J)","type":"x ∈ φ_inv J","name":["h1"],"isProp":true,"id":["_uniq",245768]},{"value":"Eq.mp (congrArg (fun _a => x ∈ _a) (Eq.symm (hφ_inv' K)))\n  (Eq.mp (congrArg (fun _a => x ∈ (↑_a : Set ℝ)) hJK) (Eq.mp (congrArg (fun _a => x ∈ _a) (hφ_inv' J)) h1))","type":"x ∈ φ_inv K","name":["h2"],"isProp":true,"id":["_uniq",245840]}]}],"start":8558},{"state":[{"type":"J = K","tag":[],"mvarId":["_uniq",257636],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)","name":["h1"],"isProp":true,"id":["_uniq",257631],"binderInfo":"default"},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑K : BoundedInterval) : Set ℝ)","name":["h2"],"isProp":true,"id":["_uniq",257632],"binderInfo":"default"}]}],"start":8583},{"state":[{"type":"φ x ∈ Icc (φ a) (φ b)","tag":[],"mvarId":["_uniq",257706],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)","name":["h1"],"isProp":true,"id":["_uniq",257631],"binderInfo":"default"},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑K : BoundedInterval) : Set ℝ)","name":["h2"],"isProp":true,"id":["_uniq",257632],"binderInfo":"default"}]}],"start":8628},{"state":[{"type":"φ x ∈ Icc (φ a) (φ b)","tag":[],"mvarId":["_uniq",257749],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)","name":["h1"],"isProp":true,"id":["_uniq",257631],"binderInfo":"default"},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑K : BoundedInterval) : Set ℝ)","name":["h2"],"isProp":true,"id":["_uniq",257632],"binderInfo":"default"},{"value":"P.contains (↑J : BoundedInterval) J.property","type":"(↑J : BoundedInterval) ⊆ Icc (φ a) (φ b)","name":["this"],"isProp":true,"id":["_uniq",257748]}]}],"start":8664},{"state":[{"type":"φ x ∈ (↑(Icc (φ a) (φ b)) : Set ℝ)","tag":[],"mvarId":["_uniq",257856],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)","name":["h1"],"isProp":true,"id":["_uniq",257631],"binderInfo":"default"},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑K : BoundedInterval) : Set ℝ)","name":["h2"],"isProp":true,"id":["_uniq",257632],"binderInfo":"default"},{"type":"(↑(↑J : BoundedInterval) : Set ℝ) ⊆ (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["this"],"isProp":true,"id":["_uniq",257853],"binderInfo":"default"}]}],"start":8712},{"state":[{"type":"J = K","tag":[],"mvarId":["_uniq",257708],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",230458],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",230459],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",230460],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",230461],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",230462],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",230463],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",230464],"binderInfo":"default"},{"type":"Partition (Icc (φ a) (φ b))","name":["P'"],"isProp":false,"id":["_uniq",230468],"binderInfo":"default"},{"value":"P'.remove_empty","type":"Partition (Icc (φ a) (φ b))","name":["P"],"isProp":false,"id":["_uniq",230482]},{"type":"PiecewiseConstantWith f P","name":["hf"],"isProp":true,"id":["_uniq",230594]},{"value":"fun J => {x | x ∈ Set.Icc a b ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)}","type":"{ x // x ∈ P.intervals } → Set ℝ","name":["φ_inv"],"isProp":false,"id":["_uniq",231268]},{"value":"fun J =>\n  Bornology.IsBounded.subset (Icc_bounded a b) fun ⦃a_1⦄ a_2 =>\n    of_eq_true\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans\n          (_root_.congr\n            (congrArg And\n              (eq_true\n                (id\n                      (Eq.mp\n                        (congrArg (fun x => a_1 ∈ x J)\n                          (funext fun J =>\n                            congrArg setOf\n                              (funext fun x =>\n                                congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ))\n                                  Set.mem_Icc._simp_1)))\n                        a_2)).1.1))\n            (eq_true\n              (id\n                    (Eq.mp\n                      (congrArg (fun x => a_1 ∈ x J)\n                        (funext fun J =>\n                          congrArg setOf\n                            (funext fun x =>\n                              congrArg (fun x_1 => x_1 ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)) Set.mem_Icc._simp_1)))\n                      a_2)).1.2))\n          (and_self True)))","type":"∀ (J : { x // x ∈ P.intervals }), Bornology.IsBounded (φ_inv J)","name":["hφ_inv_bounded"],"isProp":true,"id":["_uniq",231485]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).OrdConnected","name":["hφ_inv_connected"],"isProp":true,"id":["_uniq",242218]},{"value":"fun J => ⋯.choose","type":"{ x // x ∈ P.intervals } → BoundedInterval","name":["φ_inv'"],"isProp":false,"id":["_uniq",242283]},{"value":"fun J => Exists.choose_spec ((ordConnected_iff (φ_inv J)).mp ⟨hφ_inv_bounded J, hφ_inv_connected J⟩)","type":"∀ (J : { x // x ∈ P.intervals }), φ_inv J = (↑(φ_inv' J) : Set ℝ)","name":["hφ_inv'"],"isProp":true,"id":["_uniq",242633]},{"value":"fun J => sorry","type":"∀ (J : { x // x ∈ P.intervals }), (φ_inv J).Nonempty","name":["hφ_inv_nonempty"],"isProp":true,"id":["_uniq",242662]},{"value":"fun {J} => sorry","type":"∀ {J : { x // x ∈ P.intervals }},\n  ConstantOn (f ∘ φ) (↑(φ_inv' J) : Set ℝ) ∧\n    constant_value_on (f ∘ φ) (↑(φ_inv' J) : Set ℝ) = constant_value_on f (↑(↑J : BoundedInterval) : Set ℝ)","name":["hφ_inv_const"],"isProp":true,"id":["_uniq",242939]},{"value":"{ intervals := Finset.image φ_inv' Finset.univ, exists_unique := ⋯, contains := ⋯ }","type":"Partition (Icc a b)","name":["Q"],"isProp":false,"id":["_uniq",243351]},{"value":"sorry","type":"PiecewiseConstantWith (f ∘ φ) Q","name":["hfφ_piecewise"],"isProp":true,"id":["_uniq",243554]},{"value":"Exists.intro Q hfφ_piecewise","type":"PiecewiseConstantOn (f ∘ φ) (Icc a b)","name":["hfφ_piecewise'"],"isProp":true,"id":["_uniq",243595]},{"type":"{ x // x ∈ P.intervals }","name":["J"],"isProp":false,"id":["_uniq",245393],"binderInfo":"strictImplicit"},{"type":"J ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝¹"],"isProp":true,"id":["_uniq",245396],"binderInfo":"default"},{"type":"{ x // x ∈ P.intervals }","name":["K"],"isProp":false,"id":["_uniq",245399],"binderInfo":"strictImplicit"},{"type":"K ∈ (↑Finset.univ : Set { x // x ∈ P.intervals })","name":["a✝"],"isProp":true,"id":["_uniq",245402],"binderInfo":"default"},{"type":"φ_inv' J = φ_inv' K","name":["hJK"],"isProp":true,"id":["_uniq",245405],"binderInfo":"default"},{"value":"⋯.some","type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",245419]},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑J : BoundedInterval) : Set ℝ)","name":["h1"],"isProp":true,"id":["_uniq",257631],"binderInfo":"default"},{"type":"(a ≤ x ∧ x ≤ b) ∧ φ x ∈ (↑(↑K : BoundedInterval) : Set ℝ)","name":["h2"],"isProp":true,"id":["_uniq",257632],"binderInfo":"default"},{"value":"have this := P.contains (↑J : BoundedInterval) J.property;\nEq.mpr (id (RS_integ_of_comp._simp_3 (Icc (φ a) (φ b)) (φ x)))\n  (Eq.mp (RS_integ_eq_integ_of_mul_deriv._simp_1 (↑J : BoundedInterval) (Icc (φ a) (φ b))) this h1.right)","type":"φ x ∈ Icc (φ a) (φ b)","name":["h3"],"isProp":true,"id":["_uniq",257707]}]}],"start":8732},{"state":[],"start":8826},{"state":[],"start":8827},{"state":[],"start":8886},{"state":[],"start":8954},{"state":[],"start":9049},{"state":[],"start":9095},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",258851],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"}]}],"start":9166},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",258851],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"}]}],"start":9234},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",258859],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]}]}],"start":9256},{"state":[{"type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","tag":[],"mvarId":["_uniq",258966],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]}]}],"start":9307},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",258968],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]}]}],"start":9317},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",258983],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]}]}],"start":9414},{"state":[{"type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",259012],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]}]}],"start":9519},{"state":[{"type":"∀ (ε : ℝ), 0 < ε → upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b)) + ε","tag":["h"],"mvarId":["_uniq",259037],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]}]}],"start":9553},{"state":[{"type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b)) + ε","tag":["h"],"mvarId":["_uniq",259449],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",259445],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",259448],"binderInfo":"default"}]}],"start":9570},{"state":[{"type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b)) + ε","tag":["h"],"mvarId":["_uniq",265913],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",259445],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",259448],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_up"],"isProp":false,"id":["_uniq",265889],"binderInfo":"default"},{"type":"MajorizesOn f_up f (Icc (φ a) (φ b))","name":["hf_upmajor"],"isProp":true,"id":["_uniq",265897],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_up (Icc (φ a) (φ b))","name":["hf_upconst"],"isProp":true,"id":["_uniq",265908],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f_up (Icc (φ a) (φ b)) < upper_integral f (Icc (φ a) (φ b)) + ε","name":["hf_up"],"isProp":true,"id":["_uniq",265912],"binderInfo":"default"}]}],"start":9737},{"state":[{"type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b)) + ε","tag":["h"],"mvarId":["_uniq",265943],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",259445],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",259448],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_up"],"isProp":false,"id":["_uniq",265889],"binderInfo":"default"},{"type":"MajorizesOn f_up f (Icc (φ a) (φ b))","name":["hf_upmajor"],"isProp":true,"id":["_uniq",265897],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_up (Icc (φ a) (φ b))","name":["hf_upconst"],"isProp":true,"id":["_uniq",265908],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f_up (Icc (φ a) (φ b)) < upper_integral f (Icc (φ a) (φ b)) + ε","name":["hf_up"],"isProp":true,"id":["_uniq",265912],"binderInfo":"default"},{"value":"PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono hf_upconst","type":"PiecewiseConstantOn (f_up ∘ φ) (Icc a b) ∧\n  PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ = PiecewiseConstantOn.integ f_up (Icc (φ a) (φ b))","name":["hpc"],"isProp":true,"id":["_uniq",265942]}]}],"start":9823},{"state":[{"type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b)) + ε","tag":["h"],"mvarId":["_uniq",265964],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",259445],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",259448],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_up"],"isProp":false,"id":["_uniq",265889],"binderInfo":"default"},{"type":"MajorizesOn f_up f (Icc (φ a) (φ b))","name":["hf_upmajor"],"isProp":true,"id":["_uniq",265897],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_up (Icc (φ a) (φ b))","name":["hf_upconst"],"isProp":true,"id":["_uniq",265908],"binderInfo":"default"},{"type":"PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ < upper_integral f (Icc (φ a) (φ b)) + ε","name":["hf_up"],"isProp":true,"id":["_uniq",265958],"binderInfo":"default"},{"type":"PiecewiseConstantOn (f_up ∘ φ) (Icc a b) ∧\n  PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ = PiecewiseConstantOn.integ f_up (Icc (φ a) (φ b))","name":["hpc"],"isProp":true,"id":["_uniq",265961],"binderInfo":"default"}]}],"start":9850},{"state":[{"type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b)) + ε","tag":["h"],"mvarId":["_uniq",266011],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",259445],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",259448],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_up"],"isProp":false,"id":["_uniq",265889],"binderInfo":"default"},{"type":"MajorizesOn f_up f (Icc (φ a) (φ b))","name":["hf_upmajor"],"isProp":true,"id":["_uniq",265897],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_up (Icc (φ a) (φ b))","name":["hf_upconst"],"isProp":true,"id":["_uniq",265908],"binderInfo":"default"},{"type":"PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ < upper_integral f (Icc (φ a) (φ b)) + ε","name":["hf_up"],"isProp":true,"id":["_uniq",265958],"binderInfo":"default"},{"type":"PiecewiseConstantOn (f_up ∘ φ) (Icc a b) ∧\n  PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ = PiecewiseConstantOn.integ f_up (Icc (φ a) (φ b))","name":["hpc"],"isProp":true,"id":["_uniq",265961],"binderInfo":"default"},{"value":"fun x a_1 =>\n  id\n    (hf_upmajor (φ x)\n      (Eq.mpr (id (Eq.trans (congrArg (fun x_1 => φ x ∈ x_1) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n        (And.casesOn hf fun left right =>\n          Exists.casesOn hf_upconst fun w h =>\n            And.casesOn hpc fun left_1 right_1 =>\n              Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                  And.casesOn (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                    fun left_2 right_2 =>\n                    Exists.casesOn left fun w_3 h_3 =>\n                      Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)))","type":"MajorizesOn (f_up ∘ φ) (f ∘ φ) (Icc a b)","name":["this"],"isProp":true,"id":["_uniq",266008]}]}],"start":9960},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",259014],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]}]}],"start":10031},{"state":[{"type":"lower_integral f (Icc (φ a) (φ b)) ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":[],"mvarId":["_uniq",473148],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]}]}],"start":10136},{"state":[{"type":"∀ ε > 0, lower_integral f (Icc (φ a) (φ b)) - ε ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":["h"],"mvarId":["_uniq",473169],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]}]}],"start":10166},{"state":[{"type":"lower_integral f (Icc (φ a) (φ b)) - ε ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":["h"],"mvarId":["_uniq",473289],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",473285],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",473288],"binderInfo":"default"}]}],"start":10183},{"state":[{"type":"lower_integral f (Icc (φ a) (φ b)) - ε ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":["h"],"mvarId":["_uniq",482282],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",473285],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",473288],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_low"],"isProp":false,"id":["_uniq",482258],"binderInfo":"default"},{"type":"MinorizesOn f_low f (Icc (φ a) (φ b))","name":["hf_lowminor"],"isProp":true,"id":["_uniq",482266],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_low (Icc (φ a) (φ b))","name":["hf_lowconst"],"isProp":true,"id":["_uniq",482277],"binderInfo":"default"},{"type":"lower_integral f (Icc (φ a) (φ b)) - ε < PiecewiseConstantOn.integ f_low (Icc (φ a) (φ b))","name":["hf_low"],"isProp":true,"id":["_uniq",482281],"binderInfo":"default"}]}],"start":10363},{"state":[{"type":"lower_integral f (Icc (φ a) (φ b)) - ε ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":["h"],"mvarId":["_uniq",482312],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",473285],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",473288],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_low"],"isProp":false,"id":["_uniq",482258],"binderInfo":"default"},{"type":"MinorizesOn f_low f (Icc (φ a) (φ b))","name":["hf_lowminor"],"isProp":true,"id":["_uniq",482266],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_low (Icc (φ a) (φ b))","name":["hf_lowconst"],"isProp":true,"id":["_uniq",482277],"binderInfo":"default"},{"type":"lower_integral f (Icc (φ a) (φ b)) - ε < PiecewiseConstantOn.integ f_low (Icc (φ a) (φ b))","name":["hf_low"],"isProp":true,"id":["_uniq",482281],"binderInfo":"default"},{"value":"PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono hf_lowconst","type":"PiecewiseConstantOn (f_low ∘ φ) (Icc a b) ∧\n  PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ = PiecewiseConstantOn.integ f_low (Icc (φ a) (φ b))","name":["hpc"],"isProp":true,"id":["_uniq",482311]}]}],"start":10450},{"state":[{"type":"lower_integral f (Icc (φ a) (φ b)) - ε ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":["h"],"mvarId":["_uniq",482333],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",473285],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",473288],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_low"],"isProp":false,"id":["_uniq",482258],"binderInfo":"default"},{"type":"MinorizesOn f_low f (Icc (φ a) (φ b))","name":["hf_lowminor"],"isProp":true,"id":["_uniq",482266],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_low (Icc (φ a) (φ b))","name":["hf_lowconst"],"isProp":true,"id":["_uniq",482277],"binderInfo":"default"},{"type":"lower_integral f (Icc (φ a) (φ b)) - ε < PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ","name":["hf_low"],"isProp":true,"id":["_uniq",482327],"binderInfo":"default"},{"type":"PiecewiseConstantOn (f_low ∘ φ) (Icc a b) ∧\n  PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ = PiecewiseConstantOn.integ f_low (Icc (φ a) (φ b))","name":["hpc"],"isProp":true,"id":["_uniq",482330],"binderInfo":"default"}]}],"start":10478},{"state":[{"type":"lower_integral f (Icc (φ a) (φ b)) - ε ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","tag":["h"],"mvarId":["_uniq",482383],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",473285],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",473288],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f_low"],"isProp":false,"id":["_uniq",482258],"binderInfo":"default"},{"type":"MinorizesOn f_low f (Icc (φ a) (φ b))","name":["hf_lowminor"],"isProp":true,"id":["_uniq",482266],"binderInfo":"default"},{"type":"PiecewiseConstantOn f_low (Icc (φ a) (φ b))","name":["hf_lowconst"],"isProp":true,"id":["_uniq",482277],"binderInfo":"default"},{"type":"lower_integral f (Icc (φ a) (φ b)) - ε < PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ","name":["hf_low"],"isProp":true,"id":["_uniq",482327],"binderInfo":"default"},{"type":"PiecewiseConstantOn (f_low ∘ φ) (Icc a b) ∧\n  PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ = PiecewiseConstantOn.integ f_low (Icc (φ a) (φ b))","name":["hpc"],"isProp":true,"id":["_uniq",482330],"binderInfo":"default"},{"value":"fun x a_1 =>\n  id\n    (hf_lowminor (φ x)\n      (Eq.mpr (id (Eq.trans (congrArg (fun x_1 => φ x ∈ x_1) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n        (And.casesOn hf fun left right =>\n          Exists.casesOn hf_lowconst fun w h =>\n            And.casesOn hpc fun left_1 right_1 =>\n              Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                  And.casesOn (Eq.mp (Eq.trans (congrArg (fun x_1 => x ∈ x_1) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                    fun left_2 right_2 =>\n                    Exists.casesOn left fun w_3 h_3 =>\n                      Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)))","type":"MinorizesOn (f_low ∘ φ) (f ∘ φ) (Icc a b)","name":["this"],"isProp":true,"id":["_uniq",482380]}]}],"start":10590},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",473150],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"value":"le_of_forall_sub_le fun ε hε =>\n  (fun f_low x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ)\n                            (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 *\n                                  (Int.negOfNat 1).rawCast +\n                                0))))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                      ⋯)\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"lower_integral f (Icc (φ a) (φ b)) ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","name":["hlower"],"isProp":true,"id":["_uniq",473149]}]}],"start":10661},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",737952],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"value":"le_of_forall_sub_le fun ε hε =>\n  (fun f_low x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ)\n                            (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 *\n                                  (Int.negOfNat 1).rawCast +\n                                0))))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                      ⋯)\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"lower_integral f (Icc (φ a) (φ b)) ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","name":["hlower"],"isProp":true,"id":["_uniq",473149]},{"value":"lower_RS_integral_le_upper hfφ_bdd hφ_mono","type":"lower_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_RS_integral (f ∘ φ) (Icc a b) φ","name":["hle"],"isProp":true,"id":["_uniq",737951]}]}],"start":10765},{"state":[{"type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",737952],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",258843],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",258844],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",258845],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",258846],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",258847],"binderInfo":"implicit"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",258848],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",258849],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",258850],"binderInfo":"default"},{"value":"hf.left","type":"BddOn f (↑(Icc (φ a) (φ b)) : Set ℝ)","name":["hf_bdd"],"isProp":true,"id":["_uniq",258858]},{"value":"sorry","type":"BddOn (f ∘ φ) (↑(Icc a b) : Set ℝ)","name":["hfφ_bdd"],"isProp":true,"id":["_uniq",258967]},{"value":"hf.right","type":"lower_integral f (Icc (φ a) (φ b)) = upper_integral f (Icc (φ a) (φ b))","name":["heq"],"isProp":true,"id":["_uniq",258982]},{"value":"le_of_forall_pos_le_add fun ε hε =>\n  (fun f_up x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f (Icc (φ a) (φ b))) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (PiecewiseConstantOn.RS_integ (f_up ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                              (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (upper_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (upper_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_RS_integral (f ∘ φ) (Icc a b) φ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"upper_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_integral f (Icc (φ a) (φ b))","name":["hupper"],"isProp":true,"id":["_uniq",259013]},{"value":"le_of_forall_sub_le fun ε hε =>\n  (fun f_low x =>\n      have hpc := PiecewiseConstantOn.RS_integ_of_comp hab hφ_cont hφ_mono x.right.left;\n      have this := fun x_1 a_1 =>\n        id\n          (x.left (φ x_1)\n            (Eq.mpr (id (Eq.trans (congrArg (fun x => φ x_1 ∈ x) (set_Icc (φ a) (φ b))) Set.mem_Icc._simp_1))\n              (And.casesOn hf fun left right =>\n                Exists.casesOn x.right.left fun w h =>\n                  And.casesOn hpc fun left_1 right_1 =>\n                    Exists.casesOn (Eq.mp (congrArg (BddOn f) (set_Icc (φ a) (φ b))) hf_bdd) fun w_1 h_1 =>\n                      Exists.casesOn (Eq.mp (congrArg (BddOn (f ∘ φ)) (set_Icc a b)) hfφ_bdd) fun w_2 h_2 =>\n                        And.casesOn\n                          (Eq.mp (Eq.trans (congrArg (fun x => x_1 ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1) a_1)\n                          fun left_2 right_2 =>\n                          Exists.casesOn left fun w_3 h_3 =>\n                            Exists.casesOn left_1 fun w_4 h_4 => ⟨hφ_mono left_2, hφ_mono right_2⟩)));\n      le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ)\n                            (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt\n                          (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (PiecewiseConstantOn.RS_integ (f_low ∘ φ) (Icc a b) φ ^ Nat.rawCast 1 *\n                                  (Int.negOfNat 1).rawCast +\n                                0))))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_RS_integral (f ∘ φ) (Icc a b) φ))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f (Icc (φ a) (φ b))))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f (Icc (φ a) (φ b)) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add ⋯))))\n                      ⋯)\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯))\n    ⋯ ⋯","type":"lower_integral f (Icc (φ a) (φ b)) ≤ lower_RS_integral (f ∘ φ) (Icc a b) φ","name":["hlower"],"isProp":true,"id":["_uniq",473149]},{"value":"lower_RS_integral_le_upper hfφ_bdd hφ_mono","type":"lower_RS_integral (f ∘ φ) (Icc a b) φ ≤ upper_RS_integral (f ∘ φ) (Icc a b) φ","name":["hle"],"isProp":true,"id":["_uniq",737951]}]}],"start":10814},{"state":[],"start":10869},{"state":[],"start":10870},{"state":[],"start":10930},{"state":[],"start":10995},{"state":[],"start":11043},{"state":[],"start":11095},{"state":[],"start":11155},{"state":[],"start":11200},{"state":[],"start":11267},{"state":[],"start":11325},{"state":[{"type":"IntegrableOn (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",740517],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",740507],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",740508],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",740509],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",740510],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",740511],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ φ (↑(Icc a b) : Set ℝ)","name":["hφ_diff"],"isProp":true,"id":["_uniq",740512],"binderInfo":"default"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",740513],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",740514],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hφ'"],"isProp":true,"id":["_uniq",740515],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",740516],"binderInfo":"default"}]}],"start":11363},{"state":[{"type":"IntegrableOn (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",740546],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",740507],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",740508],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",740509],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",740510],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",740511],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ φ (↑(Icc a b) : Set ℝ)","name":["hφ_diff"],"isProp":true,"id":["_uniq",740512],"binderInfo":"default"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",740513],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",740514],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hφ'"],"isProp":true,"id":["_uniq",740515],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",740516],"binderInfo":"default"},{"value":"RS_integ_of_comp hab hφ_cont hφ_mono hf","type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","name":["h1"],"isProp":true,"id":["_uniq",740545]}]}],"start":11417},{"state":[{"type":"IntegrableOn (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) = integ f (Icc (φ a) (φ b))","tag":[],"mvarId":["_uniq",740579],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",740507],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",740508],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",740509],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["φ"],"isProp":false,"id":["_uniq",740510],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",740511],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ φ (↑(Icc a b) : Set ℝ)","name":["hφ_diff"],"isProp":true,"id":["_uniq",740512],"binderInfo":"default"},{"type":"Continuous φ","name":["hφ_cont"],"isProp":true,"id":["_uniq",740513],"binderInfo":"default"},{"type":"Monotone φ","name":["hφ_mono"],"isProp":true,"id":["_uniq",740514],"binderInfo":"default"},{"type":"IntegrableOn (derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b)","name":["hφ'"],"isProp":true,"id":["_uniq",740515],"binderInfo":"default"},{"type":"IntegrableOn f (Icc (φ a) (φ b))","name":["hf"],"isProp":true,"id":["_uniq",740516],"binderInfo":"default"},{"value":"RS_integ_of_comp hab hφ_cont hφ_mono hf","type":"RS_IntegrableOn (f ∘ φ) (Icc a b) φ ∧ RS_integ (f ∘ φ) (Icc a b) φ = integ f (Icc (φ a) (φ b))","name":["h1"],"isProp":true,"id":["_uniq",740545]},{"value":"RS_integ_eq_integ_of_mul_deriv hab hφ_mono hφ_diff hφ_cont hφ' h1.left","type":"IntegrableOn (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) ∧\n  integ (f ∘ φ * derivWithin φ (↑(Icc a b) : Set ℝ)) (Icc a b) = RS_integ (f ∘ φ) (Icc a b) φ","name":["h2"],"isProp":true,"id":["_uniq",740578]}]}],"start":11501},{"state":[],"start":11532},{"state":[],"start":11533},{"state":[],"start":11556},{"state":[],"start":11637},{"state":[],"start":11691},{"state":[{"type":"IntegrableOn (fun x => f (-x)) (Icc (-b) (-a)) ∧ integ (fun x => f (-x)) (Icc (-b) (-a)) = -integ f (Icc a b)","tag":[],"mvarId":["_uniq",767677],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",767672],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",767673],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",767674],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",767675],"binderInfo":"implicit"},{"type":"IntegrableOn f (Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",767676],"binderInfo":"default"}]}],"start":11761},{"state":[],"start":11769},{"state":[],"start":11770},{"state":[],"start":11891},{"state":[],"start":11892},{"state":[],"start":11906},{"state":[],"start":11906}]
