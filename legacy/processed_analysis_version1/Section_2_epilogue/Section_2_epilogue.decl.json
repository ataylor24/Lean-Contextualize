[{"value":{"range":[1609,1666],"original":true},"type":{"range":[1605,1608],"original":true},"signature":{"range":[1584,1608],"pp":" (n : Chapter2.Nat) : ℕ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[1484,1666],"pp":"/-- Converting a Chapter 2 natural number to a Mathlib natural number. -/\nabbrev toNat (n : Chapter2.Nat) : ℕ :=\n  match n with\n  | zero => 0\n  | succ n' => n'.toNat + 1","original":true},"params":[{"type":[1589,1601],"ref":[1585,1586],"id":[1585,1586],"bi":"default"}],"name":["Chapter2","Nat","toNat"],"modifiers":null,"kind":"abbrev","id":{"range":[1565,1583],"original":true}},{"value":{"range":[1729,1735],"original":true},"type":{"range":[1700,1728],"original":true},"signature":{"range":[1698,1728],"pp":" : (0 : Chapter2.Nat).toNat = 0","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[1668,1735],"pp":"theorem zero_toNat : (0 : Chapter2.Nat).toNat = 0 :=\n  rfl","original":false},"params":[],"name":["Chapter2","Nat","zero_toNat"],"modifiers":null,"kind":"theorem","id":{"range":[1674,1697],"original":true}},{"value":{"range":[1814,1820],"original":true},"type":{"range":[1788,1813],"original":true},"signature":{"range":[1767,1813],"pp":" (n : Chapter2.Nat) : (n++).toNat = n.toNat + 1","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[1737,1820],"pp":"theorem succ_toNat (n : Chapter2.Nat) : (n++).toNat = n.toNat + 1 :=\n  rfl","original":false},"params":[{"type":[1772,1784],"ref":[1768,1769],"id":[1768,1769],"bi":"default"}],"name":["Chapter2","Nat","succ_toNat"],"modifiers":null,"kind":"theorem","id":{"range":[1743,1766],"original":true}},{"value":{"range":[2036,2265],"original":true},"type":{"range":[2015,2035],"original":true},"signature":{"range":[2013,2035],"pp":" : Chapter2.Nat ≃ ℕ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[1822,2265],"pp":"/-- The conversion is a bijection. Here we use the existing capability (from Section 2.1) to map\nthe Mathlib natural numbers to the Chapter 2 natural numbers. -/\nabbrev equivNat : Chapter2.Nat ≃ ℕ where\n  toFun := toNat\n  invFun n := (n : Chapter2.Nat)\n  left_inv\n    n := by\n    induction' n with n hn; rfl\n    simp [hn]\n    rw [succ_eq_add_one]\n  right_inv\n    n := by\n    induction' n with n hn; rfl\n    simp [← succ_eq_add_one, hn]","original":true},"params":[],"name":["Chapter2","Nat","equivNat"],"modifiers":null,"kind":"abbrev","id":{"range":[1991,2012],"original":true}},{"value":{"range":[2390,2504],"original":true},"type":{"range":[2339,2389],"original":true},"signature":{"range":[2337,2389],"pp":" : ∀ (n m : Nat), (n + m).toNat = n.toNat + m.toNat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[2267,2504],"pp":"/-- The conversion preserves addition. -/\nabbrev map_add : ∀ (n m : Nat), (n + m).toNat = n.toNat + m.toNat :=\n  by\n  intro n m\n  induction' n with n hn\n  · rw [show zero = 0 from rfl, zero_add, _root_.Nat.zero_add]\n  sorry","original":true},"params":[],"name":["Chapter2","Nat","map_add"],"modifiers":null,"kind":"abbrev","id":{"range":[2316,2336],"original":true}},{"value":{"range":[2635,2660],"original":true},"type":{"range":[2584,2634],"original":true},"signature":{"range":[2582,2634],"pp":" : ∀ (n m : Nat), (n * m).toNat = n.toNat * m.toNat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[2506,2660],"pp":"/-- The conversion preserves multiplication. -/\nabbrev map_mul : ∀ (n m : Nat), (n * m).toNat = n.toNat * m.toNat :=\n  by\n  intro n m\n  sorry","original":true},"params":[],"name":["Chapter2","Nat","map_mul"],"modifiers":null,"kind":"abbrev","id":{"range":[2561,2581],"original":true}},{"value":{"range":[2787,2812],"original":true},"type":{"range":[2738,2786],"original":true},"signature":{"range":[2736,2786],"pp":" : ∀ {n m : Nat}, n.toNat ≤ m.toNat ↔ n ≤ m","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[2662,2812],"pp":"/-- The conversion preserves order. -/\nabbrev map_le_map_iff : ∀ {n m : Nat}, n.toNat ≤ m.toNat ↔ n ≤ m :=\n  by\n  intro n m\n  sorry","original":true},"params":[],"name":["Chapter2","Nat","map_le_map_iff"],"modifiers":null,"kind":"abbrev","id":{"range":[2708,2735],"original":true}},{"value":{"range":[2882,2989],"original":true},"type":{"range":[2858,2881],"original":true},"signature":{"range":[2856,2881],"pp":" : Chapter2.Nat ≃+*o ℕ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[2814,2989],"pp":"abbrev equivNat_ordered_ring : Chapter2.Nat ≃+*o ℕ\n    where\n  toEquiv := equivNat\n  map_add' := map_add\n  map_mul' := map_mul\n  map_le_map_iff' := map_le_map_iff","original":true},"params":[],"name":["Chapter2","Nat","equivNat_ordered_ring"],"modifiers":null,"kind":"abbrev","id":{"range":[2821,2855],"original":true}},{"value":{"range":[3128,3141],"original":true},"type":{"range":[3096,3127],"original":true},"signature":{"range":[3069,3127],"pp":" (n m : Chapter2.Nat) : n.toNat ^ m.toNat = (n ^ m).toNat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":[2991,3141],"pp":"/-- The conversion preserves exponentiation. -/\ntheorem pow_eq_pow (n m : Chapter2.Nat) : n.toNat ^ m.toNat = (n ^ m).toNat := by sorry","original":true},"params":[{"type":[3076,3088],"ref":[3070,3071],"id":[3070,3071],"bi":"default"},{"type":[3076,3088],"ref":[3072,3073],"id":[3072,3073],"bi":"default"}],"name":["Chapter2","Nat","pow_eq_pow"],"modifiers":null,"kind":"theorem","id":{"range":[3045,3068],"original":true}},{"value":{"range":[3665,3862],"original":true},"type":{"range":[3653,3664],"original":true},"signature":{"range":[3651,3664],"pp":" : PeanoAxioms","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":[3574,3862],"pp":"/-- The Chapter 2 natural numbers obey the Peano axioms. -/\ndef Chapter2_Nat : PeanoAxioms where\n  Nat := Chapter2.Nat\n  zero := Chapter2.Nat.zero\n  succ := Chapter2.Nat.succ\n  succ_ne := Chapter2.Nat.succ_ne\n  succ_cancel := Chapter2.Nat.succ_cancel\n  induction := Chapter2.Nat.induction","original":true},"params":[],"name":["PeanoAxioms","Chapter2_Nat"],"modifiers":null,"kind":"definition","id":{"range":[3638,3650],"original":true}},{"value":{"range":[3952,4089],"original":true},"type":{"range":[3940,3951],"original":true},"signature":{"range":[3938,3951],"pp":" : PeanoAxioms","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":[3864,4089],"pp":"/-- The Mathlib natural numbers obey the Peano axioms. -/\ndef Mathlib_Nat : PeanoAxioms where\n  Nat := ℕ\n  zero := 0\n  succ := Nat.succ\n  succ_ne := Nat.succ_ne_zero\n  succ_cancel := Nat.succ_inj.mp\n  induction _ := Nat.rec","original":true},"params":[],"name":["PeanoAxioms","Mathlib_Nat"],"modifiers":null,"kind":"definition","id":{"range":[3926,3937],"original":true}},{"value":{"range":[4238,4325],"original":true},"type":{"range":[4224,4237],"original":true},"signature":{"range":[4204,4237],"pp":" (P : PeanoAxioms) : ℕ → P.Nat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":[4091,4325],"pp":"/-- One can map the Mathlib natural numbers into any other structure obeying the Peano axioms. -/\nabbrev natCast (P : PeanoAxioms) : ℕ → P.Nat := fun n ↦\n  match n with\n  | Nat.zero => P.zero\n  | Nat.succ n => P.succ (natCast P n)","original":true},"params":[{"type":[4209,4220],"ref":[4205,4206],"id":[4205,4206],"bi":"default"}],"name":["PeanoAxioms","natCast"],"modifiers":null,"kind":"abbrev","id":{"range":[4196,4203],"original":true}},{"value":{"range":[4512,4525],"original":true},"type":{"range":[4482,4510],"original":true},"signature":{"range":[4462,4510],"pp":" (P : PeanoAxioms) : Function.Injective P.natCast","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":[4327,4525],"pp":"/-- One can start the proof here with `unfold Function.Injective`, although it is not strictly necessary. -/\ntheorem natCast_injective (P : PeanoAxioms) : Function.Injective P.natCast := by sorry","original":true},"params":[{"type":[4467,4478],"ref":[4463,4464],"id":[4463,4464],"bi":"default"}],"name":["PeanoAxioms","natCast_injective"],"modifiers":null,"kind":"theorem","id":{"range":[4444,4461],"original":true}},{"value":{"range":[4714,4727],"original":true},"type":{"range":[4684,4713],"original":true},"signature":{"range":[4664,4713],"pp":" (P : PeanoAxioms) : Function.Surjective P.natCast","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":[4527,4727],"pp":"/-- One can start the proof here with `unfold Function.Surjective`, although it is not strictly necessary. -/\ntheorem natCast_surjective (P : PeanoAxioms) : Function.Surjective P.natCast := by sorry","original":true},"params":[{"type":[4669,4680],"ref":[4665,4666],"id":[4665,4666],"bi":"default"}],"name":["PeanoAxioms","natCast_surjective"],"modifiers":null,"kind":"theorem","id":{"range":[4645,4663],"original":true}},{"value":{"range":[5351,5436],"original":true},"type":{"range":[5341,5350],"original":true},"signature":{"range":[5300,5350],"pp":" {P Q : PeanoAxioms} (equiv : Equiv P Q) : Equiv Q P","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":[5123,5436],"pp":"/-- This exercise will require application of Mathlib's API for the `Equiv` class.\n    Some of this API can be invoked automatically via the `simp` tactic. -/\nabbrev symm {P Q : PeanoAxioms} (equiv : Equiv P Q) : Equiv Q P\n    where\n  equiv := equiv.equiv.symm\n  equiv_zero := by sorry\n  equiv_succ n := by sorry","original":true},"params":[{"type":[5306,5317],"ref":[5301,5302],"id":[5301,5302],"bi":"implicit"},{"type":[5306,5317],"ref":[5303,5304],"id":[5303,5304],"bi":"implicit"},{"type":[5328,5337],"ref":[5320,5325],"id":[5320,5325],"bi":"default"}],"name":["PeanoAxioms","Equiv","symm"],"modifiers":null,"kind":"abbrev","id":{"range":[5289,5299],"original":true}},{"value":{"range":[5691,5791],"original":true},"type":{"range":[5681,5690],"original":true},"signature":{"range":[5616,5690],"pp":" {P Q R : PeanoAxioms} (equiv1 : Equiv P Q) (equiv2 : Equiv Q R) : Equiv P R","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":[5438,5791],"pp":"/-- This exercise will require application of Mathlib's API for the `Equiv` class.\n    Some of this API can be invoked automatically via the `simp` tactic. -/\nabbrev trans {P Q R : PeanoAxioms} (equiv1 : Equiv P Q) (equiv2 : Equiv Q R) : Equiv P R\n    where\n  equiv := equiv1.equiv.trans equiv2.equiv\n  equiv_zero := by sorry\n  equiv_succ n := by sorry","original":true},"params":[{"type":[5624,5635],"ref":[5617,5618],"id":[5617,5618],"bi":"implicit"},{"type":[5624,5635],"ref":[5619,5620],"id":[5619,5620],"bi":"implicit"},{"type":[5624,5635],"ref":[5621,5622],"id":[5621,5622],"bi":"implicit"},{"type":[5647,5656],"ref":[5638,5644],"id":[5638,5644],"bi":"default"},{"type":[5668,5677],"ref":[5659,5665],"id":[5659,5665],"bi":"default"}],"name":["PeanoAxioms","Equiv","trans"],"modifiers":null,"kind":"abbrev","id":{"range":[5604,5615],"original":true}},{"value":{"range":[5971,6142],"original":true},"type":{"range":[5951,5970],"original":true},"signature":{"range":[5931,5970],"pp":" (P : PeanoAxioms) : Equiv Mathlib_Nat P","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":[5793,6142],"pp":"/-- Useful Mathlib tools for inverting bijections include `Function.surjInv` and `Function.invFun`. -/\nnoncomputable abbrev fromNat (P : PeanoAxioms) : Equiv Mathlib_Nat P\n    where\n  equiv :=\n    { toFun := P.natCast\n      invFun := by sorry\n      left_inv := by sorry\n      right_inv := by sorry }\n  equiv_zero := by sorry\n  equiv_succ n := by sorry","original":true},"params":[{"type":[5936,5947],"ref":[5932,5933],"id":[5932,5933],"bi":"default"}],"name":["PeanoAxioms","Equiv","fromNat"],"modifiers":null,"kind":"abbrev","id":{"range":[5917,5930],"original":true}},{"value":{"range":[6309,6320],"original":true},"type":{"range":[6299,6308],"original":true},"signature":{"range":[6277,6308],"pp":" (P Q : PeanoAxioms) : Equiv P Q","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":[6144,6320],"pp":"/-- The task here is to establish that any two structures obeying the Peano axioms are equivalent. -/\nnoncomputable abbrev mk' (P Q : PeanoAxioms) : Equiv P Q := by sorry","original":true},"params":[{"type":[6284,6295],"ref":[6278,6279],"id":[6278,6279],"bi":"default"},{"type":[6284,6295],"ref":[6280,6281],"id":[6280,6281],"bi":"default"}],"name":["PeanoAxioms","Equiv","mk'"],"modifiers":null,"kind":"abbrev","id":{"range":[6267,6276],"original":true}},{"value":{"range":[6513,6658],"original":true},"type":{"range":[6497,6512],"original":true},"signature":{"range":[6431,6512],"pp":" {P Q : PeanoAxioms} (equiv1 equiv2 : PeanoAxioms.Equiv P Q) : equiv1 = equiv2","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":[6322,6658],"pp":"/-- There is only one equivalence between any two structures obeying the Peano axioms. -/\ntheorem uniq {P Q : PeanoAxioms} (equiv1 equiv2 : PeanoAxioms.Equiv P Q) : equiv1 = equiv2 :=\n  by\n  obtain ⟨equiv1, equiv_zero1, equiv_succ1⟩ := equiv1\n  obtain ⟨equiv2, equiv_zero2, equiv_succ2⟩ := equiv2\n  congr\n  ext n\n  sorry","original":true},"params":[{"type":[6438,6449],"ref":[6432,6433],"id":[6432,6433],"bi":"implicit"},{"type":[6438,6449],"ref":[6434,6435],"id":[6434,6435],"bi":"implicit"},{"type":[6468,6489],"ref":[6452,6458],"id":[6452,6458],"bi":"default"},{"type":[6468,6489],"ref":[6459,6465],"id":[6459,6465],"bi":"default"}],"name":["PeanoAxioms","Equiv","uniq"],"modifiers":null,"kind":"theorem","id":{"range":[6420,6430],"original":true}},{"value":{"range":[6918,6931],"original":true},"type":{"range":[6842,6917],"original":true},"signature":{"range":[6776,6917],"pp":" {P : PeanoAxioms} (f : P.Nat → P.Nat → P.Nat) (c : P.Nat) :\n  ∃! (a : P.Nat → P.Nat), a P.zero = c ∧ ∀ n, a (P.succ n) = f n (a n)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Nat"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Nat"]},"ref":{"range":[6660,6931],"pp":"/-- A sample result: recursion is well-defined on any structure obeying the Peano axioms-/\ntheorem recurse_uniq {P : PeanoAxioms} (f : P.Nat → P.Nat → P.Nat) (c : P.Nat) :\n    ∃! (a : P.Nat → P.Nat), a P.zero = c ∧ ∀ n, a (P.succ n) = f n (a n) := by sorry","original":true},"params":[{"type":[6781,6792],"ref":[6777,6778],"id":[6777,6778],"bi":"implicit"},{"type":[6798,6823],"ref":[6795,6796],"id":[6795,6796],"bi":"default"},{"type":[6829,6834],"ref":[6826,6827],"id":[6826,6827],"bi":"default"}],"name":["PeanoAxioms","Nat","recurse_uniq"],"modifiers":null,"kind":"theorem","id":{"range":[6759,6775],"original":true}}]
